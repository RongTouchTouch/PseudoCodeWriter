[iTC_CC_ATP-SwRS-0053] On initialization, ATP generates TrainType according to DataPlugContent.CCTrainType from the CC data plug.    ATP ; TrainType ; DataPlugContent.CCTrainType ; CC data plug    <system> <variable> <variable> <interface>     1 0 0  ; 2 0 3 ; 2 1 1    def <variable_1>(k): return <variable_2>     1 2 7 4 -1
[iTC_CC_ATP-SwRS-0054] On initialization, ATP generates CoreId according to DataPlugContent.CCCoreId read from the CC data plug.    ATP ; CoreId ;  DataPlugContent.CCCoreId ; CC data plug    <system> <variable> <variable> <interface>    1 0 0 ; 2 0 3 ; 2 1 1    def <variable_1>(k): return <variable_2>    1 2 7 4 -1
[iTC_CC_ATP-SwRS-0613] OtherCoreId, core id for CC on the distant cab.    OtherCoreId ;  CC ; cab    <variable> <system> <hardware>    0 0 1 ; 2 5 1    def <variable_0>(k): if (CoreId(k) is END_1):  return END_2 elif (CoreId(k) is END_2):  return END_1 else:  return None    3 -1 3 -1 3 -1
[iTC_CC_ATP-SwRS-0055] On initialization, ATP generates SubSystemId according to DataPlugContent.CC_SSID from the CC data plug.    ATP ; SubSystemId ; DataPlugContent.CC_SSID ; CC data plug    <system> <variable> <variable> <interface>    1 0 0 ; 2 0 3 ; 2 1 1    def <variable_1>(k): return <variable_2>    1 2 4 7 -1
[iTC_CC_ATP-SwRS-0059] After all above-mentioned information has corrected, and correspondingly, ATP will generate TrainKnown information. If TrainKnown considered as False, ATP shall set all output ports as restricted.    ATP ; TrainKnown ;  False ; output ports    <system> <variable> <constant> <interface>    1 0 0 ; 2 2 1 ; 0 5 3 ; 3 1 1    def <variable_1>(k): return ((TrainType(k) == ATPsetting.TrainTypeId) and (CoreId(k) is END_1 or CoreId(k) is END_2) and IdenticalVersionOfDualCPU(k))    1 4 -1
[iTC_CC_ATP-SwRS-0125] Through the communication with CCNV, ATP judges NonVitalRequest received from CCNV and generates NonVitalRequestReady If received a new message.    CCNV ; ATP ; NonVitalRequest ; NonVitalRequestReady    <system> <system> <variable> <variable>    0 3 1 ; 2 0 0 ; 3 0 1 ; 2 1 3    def <variable_3>(k): return Message.Exists(<variable_2>)    3 2 8 4 -1
[iTC_CC_ATP-SwRS-0126] ATOcontrolTimeValid stands for the effectiveness of CCNV message. If there is no updating CCNV message past the CCNV_VALIDITY_CYCLES, ATOcontrolTimeValid is set as False.    ATOcontrolTimeValid ; CCNV ; CCNV message ; CCNV_VALIDITY_CYCLES ; False    <variable> <system> <message> <statevariable> <constant>    0 6 2 ; 4 2 0 ; 2 1 0 ; 2 6 3    def <variable_0>(k): if (NonVitalRequestReady(k)):  <variable_0>= True  ATOcontrolTimer = 0 elif (ATOcontrolTimer(k-1) < <statevariable_3>):  ATOcontrolTimer = ATOcontrolTimer(k-1) + 1 else:  <variable_0>= <constant_4> return <variable_0>    0 3 4 7 5 -1
[iTC_CC_ATP-SwRS-0468] VIOM1VitalInputsReceived, ATP determines whether received a safety input message from VIOM1.    ATP ; safety input message ; VIOM1 ; VIOM1VitalInputsReceived    <system> <message> <interface><variable>    0 3 2 ; 1 0 2 ; 3 1 0    def <variable_3>(viomId, k): return Message.Received(VIOM1VitalInput(viomId), k)    3 4 -1
[iTC_CC_ATP-SwRS-0060] Through the communication, ATP gets the vital input message from VIOM1 and decides the time effectiveness and the correctness of the sequence of the message, which defined as VIOM1VitalInputsAvailable.    ATP ; VIOM1 ; time effectiveness ; correctness ; VIOM1VitalInputsAvailable ; vital input message   <system> <interface> <otheritem> <otheritem> <variable> <message>   0 3 1 ;  2 7 3 ; 0 1 2 ; 0 1 3 ; 4 4 5 ; 5 0 1   def <variable_4>(ViomId, k): return Message.Available(VIOM1VitalInputsReceived(ViomId, k), VIOM1VitalInput(ViomId).AtpLoopHour, VIOM_VALIDITY_TIME, VIOM1VitalInputsLastAge(ViomId, k-1), k)    4 6 -1
[iTC_CC_ATP-SwRS-0740] VIOM1VitalInputsLastAge, records the survival time of received vital inputs from VIOM1.     survival time ; VIOM1 ; vital inputs ; VIOM1VitalInputsLastAge    <time> <interface> <otheritem> <variable>    0 0 1 ; 2 9 0 ; 3 4 0    def <variable_3>(ViomId, k): return Message.LastAge(VIOM1VitalInputsAvailable(ViomId, k), VIOM1VitalInput(ViomId).AtpLoopHour <variable_3>(ViomId, k-1), k)    3 4 -1
[iTC_CC_ATP-SwRS-0572] ATP records the latest cycle time information of VIOM in END_1 by the term LatestVIOM1LoopHourVIOM. In initialization, set LatestVIOM1LoopHourVIOM as the zero; If receiving an available VIOM1 message, or a new message and the previous one has invalid, ATP will set the related value of LatestVIOM1LoopHourVIOM as the viomLoopHour of the message. Otherwise, LatestVIOM1LoopHourVIOM keeps unchanged.    ATP ; cycle time ; VIOM ; END_1 ; LatestVIOM1LoopHourVIOM ; zero ; VIOM1 message ; viomLoopHour ; invalid    <system> <time> <interface> <statevariable> <variable> <constant> <message> <variable> <state>    1 0 2 ; 0 8 1 ; 4 8 1 ; 1 0 3 ; 5 2 4 ; 6 1 3 ; 7 1 4 ; 8 6 4    def <variable_4>(ViomId, k): if (VIOM1VitalInputsAvailable(k) or (not VIOM1VitalInputsValid(k-1) and VIOM1VitalInputsReceived(ViomId, k))):  return VIOM1VitalInput[ViomId].<variable_7>else:  return <variable_4>[ViomId](k-1)    4 7 15 9 -1
[iTC_CC_ATP-SwRS-0614] VIOM2VitalInputsReceived, ATP determines whether received a safety input message from VIOM2.    ATP ; safety input message ; VIOM2 ; VIOM2VitalInputsReceived    <system> <otheritem> <interface> <variable>    0 3 2 ; 1 0 2 ; 1 6 3    def <variable_3>(ViomId, k): return Message.Received(VIOM2VitalInput(ViomId), k)    3 4 -1
[iTC_CC_ATP-SwRS-0449] Through the communication, ATP gets the vital input message from VIOM2 and decides the time effectiveness and the correctness of the sequence of the message, which defined as VIOM2VitalInputsAvailable. During the calculation, the value i is either zero or one, which represents one of the two VIOM in the train END_2.    ATP ; VIOM2 ; time effectiveness ; correctness ; VIOM2VitalInputsAvailable ; zero ; one ; VIOM ; END_2 ; vital input message   <system> <interface> <otheritem> <otheritem> <variable> <constant> <constant> <interface> <statevariable> <message>    0 3 1 ;  2 7 3 ; 0 1 2 ; 0 1 3 ; 4 4 9 ; 9 0 1 ; 7 0 8 ; 5 1 7 ; 6 1 7    def <variable_4>(ViomId, k): return Message.Available(VIOM2VitalInputsReceived(ViomId, k), VIOM2VitalInput(ViomId).AtpLoopHour, VIOM_VALIDITY_TIME, VIOM2VitalInputsLastAge(ViomId, k-1), k)    4 10 -1 
[iTC_CC_ATP-SwRS-0741] VIOM2VitalInputsLastAge, records the survival time of received vital inputs from VIOM2.    survival time ; vital inputs ; VIOM2 ; VIOM2VitalInputsLastAge    <time> <otheritem> <interface> <variable>    1 9 0 ; 0 0 2 ; 3 4 0    def <variable_3>(viomId, k): return Message.LastAge(VIOM2VitalInputsAvailable(viomId, k) VIOM2VitalInput(viomId).AtpLoopHour, <variable_3>(viomId, k-1), k)    3 4 -1
[iTC_CC_ATP-SwRS-0573] ATP records the latest cycle time information of VIOM in END_2 by the term LatestVIOM2LoopHourVIOM. In initialization, set LatestVIOM2LoopHourVIOM as the zero; If receiving an available VIOM1 message, or a new message and the previous one has invalid, ATP will set the related value of LatestVIOM2LoopHourVIOM as the viomLoopHour of the message. Otherwise, LatestVIOM2LoopHourVIOM keeps unchanged.    ATP ; cycle time ; VIOM ; END_2 ; LatestVIOM2LoopHourVIOM ; zero ; VIOM1 message ; viomLoopHour ; invalid    <system> <time> <interface> <statevariable> <variable> <constant> <message> <variable> <state>    1 0 2 ; 0 8 1 ; 4 8 1 ; 1 0 3 ; 5 2 4 ; 6 1 3 ; 7 1 4 ; 8 4 6    defLatestVIOM2LoopHourVIOM<variabel_4>(ViomId, k): if (VIOM2VitalInputsAvailable(k) or (not VIOM2VitalInputsValid(k-1) and VIOM2VitalInputsReceived(ViomId, k))):  return VIOM2VitalInput[ViomId].<variable_7> else:  return<variabel_4>[ViomId](k-1)    4 7 15 9 -1
[iTC_CC_ATP-SwRS-0538] VIOM1VitalInputsValid, ATP determines whether the vital inputs message from VIOM1 valid.    ATP ; vital inputs message ; VIOM1 ; VIOM1VitalInputsValid ; valid    <system> <message> <interface> <variable> <state>    1 0 2 ; 0 3 2 ; 1 6 3 ; 3 6 4    def <variable_3>(k): return (Message.Valid(VIOM1VitalInput(1).AtpLoopHour, VIOM_VALIDITY_TIME) or Message.Valid(VIOM1VitalInput(2).AtpLoopHour, VIOM_VALIDITY_TIME))    3 5 -1
[iTC_CC_ATP-SwRS-0539] VIOM2VitalInputsValid, ATP determines whether the vital inputs message from VIOM2 valid.    ATP ; vital inputs message ; VIOM2 ; VIOM2VitalInputsValid ; valid    <system> <message> <interface> <variable> <state>    1 0 2 ; 0 3 2 ; 1 6 3 ; 3 6 4    def <variable_3>(k): return (Message.Valid(VIOM2VitalInput(1).AtpLoopHour, VIOM_VALIDITY_TIME) or Message.Valid(VIOM2VitalInput(2).AtpLoopHour, VIOM_VALIDITY_TIME))    3 5 -1
[iTC_CC_ATP-SwRS-0075] CoupledByEnd1 or CoupledByEnd2 shows that both ends of train connect with other trains. If the project is not configured with the capture of coupling input, it is certain that the train does not connect with other trains.    CoupledByEnd1 ;  CoupledByEnd2 ; ends of train ; coupling input    <variable> <variable> <hardware> <otheritem>    0 7 1 ; 0 6 2 ; 1 6 2    def <variable_0>(k): return Offline.GetCoupledByEnd1(k) def <variable_1>(k): return Offline.GetCoupledByEnd2(k)    0 1 5 4 -1
[iTC_CC_ATP-SwRS-0144] ATPtime stands for the ATP loop hour of this train END. Based on CoreId, ATP initialize ATPtime as the initiative value of END_1 or END_2; If the value exceeds the maximum loop hour, ATP shall set it as the initiative value; Otherwise, add one for each cycle.   ATPtime ;  ATP ; ATP loop hour ; train END ; END ; CoreId ;  END_1 ; END_2 ;  maximum loop hour ; cycle ; one    <variable> <system> <time> <hardware> <statevariable> <variable> <statevarable> <statevariable> <time> <otheritem> <constant>    0 4 2 ; 2 0 3 ; 5 1 0 ; 0 0 1 ; 6 7 7 ; 6 2 0 ; 7 2 0 ; 1 6 0 ; 6 10 8 ; 7 10 8 ; 8 1 0    def ATPtime(k): if (CoreId(k) is END_1):  if (Initialization):   return CC1_INIT_TIME  elif (<variable_0>(k-1) >= CC1_MAX_TIME):   return CC1_INIT_TIME  else:   return <variable_0>(k-1) + <constant_10> else:  if (Initialization):   return CC2_INIT_TIME  elif (<variable_0>(k-1) >= CC2_MAX_TIME):   return CC2_INIT_TIME  else:   return <variable_0>(k-1) + <constant_10>    0 10 11 -1
[iTC_CC_ATP-SwRS-0615] OtherATPmessageReceived, the message transmitted from the distant ATP in the other END shall be protected by checking words. And before using the information, ATP shall verify the check words.    OtherATPmessageReceived ;  ATP ; the other END ; check words    0 6 3    def <variable_0>(k): return Message.Received(OtherCCsynchroReport,k)    0 4 -1
[iTC_CC_ATP-SwRS-0078] OtherATPmessageAvailable, ATP shall judge the effectiveness of message from the redundant ATP, shown as following pseudo-codes:    OtherATPmessageAvailable ; ATP ; effectiveness ; redundant ATP    <variable> <system> <otheritem> <system>    0 6 2    def <variable_0>(k): return Message.Available(OtherATPmessageReceived(k), OtherCCsynchroReport.LatestTimeOtherCore, OTHER_ATP_VALIDITY_TIME, LastOtherATPmessageAge(k-1), k)    0 4 -1
[iTC_CC_ATP-SwRS-0540] OtherATPmessageValid represents the effectiveness of the messages from redundant ATP. If this message is invalid, ATP will set OtherATPmessageValid as False; otherwise, it is set as True.    OtherATPmessageValid ; effectiveness ; invalid ; False ; True    <variable> <otheritem> <state> <constant> <constant>    3 2 0 ; 4 2 0 ; 0 6 1    def <variable_0>(k): return Message.Valid(OtherCCsynchroReport.LatestTimeOtherCore, OTHER_ATP_VALIDITY_TIME, k)    0 5 -1
[iTC_CC_ATP-SwRS-0081] The OtherATPminTime stands for the local ATP maintained minimum time of the redundant ATP. The setting rule is as following: In initialization, ATP set the OtherATPminTime as default value based on the CoreId of the redundant ATP. Or else:, if the updating message from the new redundant ATP in this cycle is available, ATP will update OtherATPminTime as the current time in the message. Or else:, if the redundant ATP message is still effective, ATP will add one in the OtherATPminTime until it is out of bound, and set is as initialization value. Or else:, If the received a new redundant ATP message, but it was not available, ATP shall update OtherATPminTime as in the message. Otherwise, accumulate OtherATPminTime.    OtherATPminTime ; ATP ; maintained minimum time ; redundant ATP ; CoreId ; updating message ; available ; effective ; one ; out of bound ; not available ; redundant ATP message    <variable> <system> <time> <system> <variable> <message> <state> <state> <constant> <state> <state> <message>    0 4 2 ; 2 0 3 ; 4 1 0 ; 4 0 3 ; 5 1 0 ; 6 2 5 ; 11 1 0 ; 7 2 11 ; 0 6 9 ; 0 6 8 ; 9 2 11    if (<variable_4>== END_1) if (Initialization)   <variable_0> = CC2_INIT_TIME elif ((OtherATPmessageAvailable(k) == True) or ((OtherATPmessageValid(k) == False) and Exists(OtherCCsynchroReport)))   <variable_0>= OtherCCsynchroReport.CurrentTime else:  if (<variable_0>(k-1) >= CC2_MAX_TIME)   <variable_0>= CC2_INIT_TIME  else:   <variable_0>= <>variable_0(k-1) + <constant_8> else:  if (Initialization)   <variable_0>= CC1_INIT_TIME  elif ((OtherATPmessageAvailable(k) == True) or ((OtherATPmessageValid(k) == False) and Exists(OtherCCsynchroReport))   <variable_0>= OtherCCsynchroReport.CurrentTime  else:   if (<variable_0>(k-1) >= CC1_MAX_TIME)    <variable_0>= CC1_INIT_TIME   else:    <variable_0>= <variable_)>(k-1) + <constant_8>    4 0 8 15 22 12 -1
[iTC_CC_ATP-SwRS-0083] The OtherATPmaxTime stands for the local ATP maintained maximum time of the redundant ATP. The rules to update OtherATPmaxTime are similar with OtherATPminTime except that when received a new message from the redundant ATP, the OtherATPmaxTime shall add the maximum transmission delay in network.    OtherATPmaxTime ; maintained maximum time ; ATP ; redundant ATP ; OtherATPminTime ; maximum transmission delay    <variable> <time> <system> <system> <variable> <otheritem>    0 4 1 ; 1 0 3 ; 4 1 0 ; 0 6 5    if (CoreId == END_1) if (Initialization) <variable_0>= CC2_INIT_TIME elif ((OtherATPmessageAvailable(k) == True) or ((OtherATPmessageValid(k) == False) and Exists(OtherCCsynchroReport)))  <variable_0>= OtherCCsynchroReport.CurrentTime + LoopHourModularSub(ATPtime(k), OtherCCsynchroReport.LatestTimeOtherCore) else  if (<variable_0>(k-1) >= CC2_MAX_TIME)   <variable_0>= CC2_INIT_TIME  else:   <variable_0>= <variable_0>(k-1) + 1 else:  if (Initialization)   <variable_0>= CC1_INIT_TIME  elif ((OtherATPmessageAvailable(k) == True) or ((OtherATPmessageValid(k) == False) and Exists(OtherCCsynchroReport)))   <variable_0>= OtherCCsynchroReport.CurrentTime + LoopHourModularSub(ATPtime(k), OtherCCsynchroReport.LatestTimeOtherCore)  else:   if (<variable_0>(k-1) >= CC1_MAX_TIME)    <variable_0>= CC1_INIT_TIME   else:    <variable_0>= <variable_0>(k-1) + 1    0 6 -1
[iTC_CC_ATP-SwRS-0080] OtherATP, parse and store messages from the distant ATP. In initialization or the message has expired, set all variables as default value; when new message available, set the corresponding value from the new message; otherwise, remain unchanged. OtherATP ; distant ATP ;  expired ;  default value ; available ;  unchanged    <variable> <system> <state> <otheritem> <state> <state>    0 6 1 ; 3 1 0 ; 2 1 3 ; 4 1 5 ; 4 1 0 ; 2 7 5    def <variable_0>(k): if (Initialization or (not OtherATPmessageValid(k))):  <variable_0>.LatestTimeOtherCore = INVALID_LOOP_HOUR  <variable_0>.CoreId = None  <variable_0>.BeaconId = None  <variable_0>.EnableDoorOpening_A = False  <variable_0>.EnableDoorOpening_B = False <variable_0>.PsdManagerOpeningOrder = False  <variable_0>.PsdIdSide_A = None  <variable_0>.PsdValiditySide_A = None  <variable_0>.PsdClosedSide_A = False  <variable_0>.PsdIdSide_B = None <variable_0>.PsdValiditySide_B = None <variable_0>.PsdClosedSide_B = False  <variable_0>.ZcVersion = None  <variable_0>.LocatedOnKnownPath = False  <variable_0>.LocatedWithMemLocation = False  <variable_0>.Location.Ext2 = None  <variable_0>.Location.Uncertainty = None  <variable_0>.Location.Ext1 = None  <variable_0>.SleepZoneId = None  <variable_0>.SleepZoneVersion = None  <variable_0>.MotionSinceLastReloc = None  <variable_0>.MotionSinceMemLoc = None  <variable_0>.TrainFilteredStopped = False  <variable_0>.SafetyParameterVersion = None  <variable_0>.SafetyApplicationVersion = None  <variable_0>.CC_SSID = None  <variable_0>.OverlapExpired = False elif (OtherATPmessageAvailable(k)): <variable_0>.LatestTimeOtherCore = OtherCCsynchroReport.LatestTimeOtherCore(k) <variable_0>.CoreId = OtherCCsynchroReport.CoreId  <variable_0>.BeaconId = OtherCCsynchroReport.BeaconId  <variable_0>.EnableDoorOpening_A = OtherCCsynchroReport.EnableDoorOpening_A  <variable_0>.EnableDoorOpening_B = OtherCCsynchroReport.EnableDoorOpening_B  <variable_0>.PsdManagerOpeningOrder = OtherCCsynchroReport.PsdManagerOpeningOrder  <variable_0>.PsdIdSide_A = OtherCCsynchroReport.PsdIdSide_A  <variable_0>.PsdValiditySide_A = OtherCCsynchroReport.PsdValiditySide_A  <variable_0>.PsdClosedSide_A = OtherCCsynchroReport.PsdClosedSide_A  <variable_0>.PsdIdSide_B = OtherCCsynchroReport.PsdIdSide_B  <variable_0>.PsdValiditySide_B = OtherCCsynchroReport.PsdValiditySide_B  <variable_0>.PsdClosedSide_B = OtherCCsynchroReport.PsdClosedSide_B  <variable_0>.ZcVersion = OtherCCsynchroReport.ZcVersion  <variable_0>.LocatedOnKnownPath = OtherCCsynchroReport.LocatedOnKnownPath  <variable_0>.LocatedWithMemLocation = OtherCCsynchroReport.LocatedWithMemLocation  <variable_0>.Location.Ext2 = OtherCCsynchroReport.Location.Ext2  <variable_0>.Location.Uncertainty = OtherCCsynchroReport.Location.Uncertainty  <variable_0>.Location.Ext1 = OtherCCsynchroReport.Location.Ext1  <variable_0>.SleepZoneId = OtherCCsynchroReport.SleepZoneId  <variable_0>.SleepZoneVersion = OtherCCsynchroReport.SleepZoneVersion  <variable_0>.MotionSinceLastReloc = OtherCCsynchroReport.MotionSinceLastReloc    0 6 -1
[iTC_CC_ATP-SwRS-0067]  BlockModeUsed represents that either of train end chooses BM mode.    BlockModeUsed ; BM mode ; train end    <variable> <mode> <hardware>    0 6 2    def <variable_0>(k): return Offline.GetBlockModeUsed(k)    0 3 -1 
[iTC_CC_ATP-SwRS-0066] The status of BMvariantValidWhileTemporallyValid shows whether it is in the BM mode.    BMvariantValidWhileTemporallyValid ; BM mode    <variable> <mode>    0 6 1    def <variable_0>(k): return Offline.GetBMvariantValidWhileTemporallyValid(k)
[iTC_CC_ATP-SwRS-0146] BeaconVariantsUpdating used to determine ATP whether to update the BM variants in this cycle. If all the following conditions are fulfilled, ATP shall set BeaconVariantsUpdating as True: The current operational mode is BLOCK MODE; And train moved and ATP received a BM beacon in this cycle; And the train is either not localized, or the direction of the BM variants is as same as the orientation of the train front end. Otherwise, ATP shall set BeaconVariantsUpdating as False.    BeaconVariantsUpdating ; ATP ; BM variants ; fulfilled ; True ; BLOCK MODE ; BM beacon ; not localized ; direction ; train front end ; False    <variable> <system> <otheritem> <state> <constant> <statevariable> <beacon> <state> <otheritem> <hardware> <constant>    0 1 2 ; 1 1 2 ; 4 2 0 ; 3 1 0 ; 10 2 0 ; 9 9 8 ; 5 7 7    def <variable_0>(k): return (BMvariantValidWhileTemporallyValid(k) and BeaconMessageReceive(k) and TrackMap.IsBmBeacon(BeaconMessage.ID) and not TrainFilteredStopped(k) and (not TrainLocalized(k-1) or (TrackMap.BmBeaconDirection(BeaconMessage.ID)== TrainFrontOrientation(k-1))))    0 11 -1
[iTC_CC_ATP-SwRS-0148] UsedBMbeaconId records the used BM variants came from BM beacon: When one of the following conditions fulfilled, ATP clear the UsedBMbeaconId: initialization, the BLOCK MODE variant is not temporally valid, the direction of the used BM beacon is not as same as train front orientation, the train is not localized. Or else:, when received a valid BM beacon, ATP update UsedBMbeaconId; Otherwise, keep this value unchanged.    UsedBMbeaconId ; BM variants ; BM beacon ; ATP ; BLOCK MODE ; not temporally valid ; direction ; train front orientation ; not localized ; unchanged ; fullfilled    <variable> <otheritem> <beacon> <system> <statevariable> <state> <otheritem><otheritem> <state> <state> <state>    0 8 1 ; 1 0 2 ; 10 1 0 ; 3 1 0 ; 5 2 4 ; 2 9 6 ; 6 10 7 ; 9 1 0 ; 8 1 0    def <variable_0>(k): if (BeaconVariantsUpdating(k)):  return BeaconMessage.Id elif (Initialization or not BMvariantValidWhileTemporallyValid(k) or (TrainLocalized(k-1) and (TrackMap.BmBeaconDirection(<variable_0>(k-1)) is not TrainFrontOrientation(k-1))) or (TrainLocalized(k-1) and not TrainLocalized(k))):  return None else:  return <variable>(k-1)    0 11 -1
[iTC_CC_ATP-SwRS-0093] SameVersionWithDistantCore, the local ATP shall compare the information from the redundant ATP to ensure the consistency, which includes versions of vital software, project configuration data and the track map.    local ATP ; redundant ATP ; versions ; project configuration data ; track map ; SameVersionWithDistantCore    <system> <system> <otheritem> <otheritem> <otheritem> <variable>    0 3 1 ; 2 7 3 ; 2 7 4 ; 3 7 4    def <variable_5>(k): if (OtherATPmessageValid(k) and (OtherATP.SafetyParameterVersion == ATPsetting.SafetyParameterVersion) and (OtherATP.SafetyApplicationVersion == SafeApplicationVersion)):  for ZcId in range(0, MAX_ZC_NB):   if (OtherATP.ZcVersion[ZcId] != TrackMap.ZC[ZcId].Version):    return False   else:    continue  else:   return True else:  return False    5 6 -1
[iTC_CC_ATP-SwRS-0105] ZCmessageReady represents an available EOA and variants message from ZC received in this cycle.    ZCmessageReady ; EOA ; ZC ; variants message    <variable> <message> <interface> <message>    0 4 1 ; 0 4 3 ; 1 7 3 ; 3 0 2    def <variable_0>(k): return (Message.Available(EOAReportReceived(k), EOA_Report.CcLoopHour, ATPsetting.EOAvalidityTime, LastEOAReportAge(k-1), k) and (VersionAuthorizedByLC(SSIDofZC, k)) and (Message.ReplyLocalCC(EOA_Report.CcLoopHour) or SameVersionWithDistantCore(k)))    0 4 -1
[iTC_CC_ATP-SwRS-0108] LastEOAReportAge represents the value calculated by current ATP time minus the previous loc-report number and the EOA consuming time in ZC.    LastEOAReportAge ; current ATP time ; previous loc-report number ; EOA consuming time ; ZC    <variable> <time> <otheritem> <time> <interface>    1 1 0 ; 2 1 0 ; 3 1 0; 1 7 2; 1 7 3 ; 2 7 3 ;3 0 4    def <variable_0>(k): return Message.LastAge(ZCmessageReady(k), EOA_Report.CcLoopHour, LastEOAReportAge(k-1), k)    0 5 -1
[iTC_CC_ATP-SwRS-0106] EOAgroundAge stands for the number of CC cycle when receiving the EOA information.    EOAgroundAge ; number of CC cycle ; EOA information    <variable> <otheritem> <message>    0 4 1 ; 2 1 0    def <variable_0>(k): if (Initialization):  <variable_0>(.WithoutSpacing = REPORT_AGE_MAX  <variable_0>.Classic = REPORT_AGE_MAX elif (ZCmessageReady(k)):  <variable_0>.WithoutSpacing = (round.ceil ((EOA_Report.MessageContainerCreationTime - EOA_Report.WithoutSpacingEoaCreationTime) * SYNCHRODATE_TIME_UNIT_MS / ATP_CYCLE_TIME_MS))  <variable_0>.Classic = round.ceil((EOA_Report.MessageContainerCreationTime - EOA_Report.EoaCreationTime) * SYNCHRODATE_TIME_UNIT_MS / ATP_CYCLE_TIME_MS) else:  <variable_0>=<variable_0>(k-1) return <variable_0>    0 3 -1
[iTC_CC_ATP-SwRS-0109] VariantGroundAge shows the survival time of the variants in ZC.    VariantGroundAge ; survival time ; variants in ZC    <variable> <time> <otheritem>    0 4 1 ; 2 9 1    def <variable_0>(lineSec, k): <variable_0> = round.ceil((EOA_Report.MessageContainerCreationTime - VariantReport(lineSec).CreationTime) * SYNCHRODATE_TIME_UNIT_MS / ATP_CYCLE_TIME_MS) return <variable_0>    0 3 -1
[iTC_CC_ATP-SwRS-0150] CBTCvariantValue, ATP shall maintain the validation of CBTC variants message from ZC. if the validation timeout, ATP should set all CBTC variants to restrictive state.    ATP ; validation ; CBTC variants message ; timeout ; restrictive state ; ZC ; CBTCvariantValue    <system> <state> <message> <state> <state> <interface> <variable>    2 9 1 ; 0 1 2 ; 2 0 5 ; 3 1 6 ; 4 2 2 ; 3 1 2    def <variable_6>(Variant, k): if (ReceivedVariantReport(Variant.LineSec.Id, k).ValidityTime > ATPtime(k)):  return ReceivedVariantReport(Variant.LineSec.Id, k).Status(Variant.LineSec.Index) else:  return False    6 7 -1
[iTC_CC_ATP-SwRS-0118] BeaconCount represents the accumulated number of received Top-loc signal from power on to current cycle.    BeaconCount ; Top-loc signal ; power on ; current cycle    <variable> <otheritem> <state> <state>    2 7 3 ; 1 1 0 ; 1 0 2 ; 1 0 3    if (Initialization)  <variable_0>= 0 else:  <variable_0>= LockedTopLocCounter(k) + BeaconCount(k-1)    0 4 -1
[iTC_CC_ATP-SwRS-0121] If the status of BeaconMessageReceive is True, the BeaconMessage.ID is obtained by LockedBeaconMsgByte; Otherwise, keep it unchanged.    BeaconMessageReceive ; True ; BeaconMessage.ID ; LockedBeaconMsgByte ; unchanged    <variable> <constant> <variable> <variable> <state>    1 2 0 ; 3 4 2 ; 1 1 3 ; 4 2 3 ; 0 1 3    if (Initialization) <variable_2> = 0 elif (<variable_0> (k)) <variable_2> = <variable_3> [BEACON_ID_BITS] else: <variable_2> = <variable_2> (k-1)    2 0 3 7 10 5 -1
[iTC_CC_ATP-SwRS-0122] If the BeaconMessageReceive is True, the variants is come from LockedBeaconMsgByteand ATP set as BeaconMessage.Variants[MAX_BM_VARIANT_NB]; if there is no beacon read at the end of cycle, there is no changes. BM_VARIANTS_BIT_0...BM_VARIANTS_BIT_15 represents the index of BM beacon variants defined in [REF4].    BeaconMessageReceive ; True ; LockedBeaconMsgByte ; BeaconMessage.Variants ; BM_VARIANTS_BIT_0 ; .BM_VARIANTS_BIT_15 ; BM beacon variants ; [REF4] ; [MAX_BM_VARIANT_NB]    <variable> <constant> <variable> <variable> <statevariable> <statevariable> <otheritem> <otheritem> <statevariable>    1 2 0 ; 0 1 2 ; 3 2 2 ;  4 7 5 ; 4 4 6 ; 5 4 6 ; 6 0 7    if (Initialization) <variable_3> = {0,..,0} elif (<variable_0> (k))  <variable_3> (k) = {<variable_2> [<statevariable_4> ],  ...,  <variable_2> [<statevariable_5> } else:  <variable_3> = <variable_3> (k-1)    3 0 2 4 5 11 12 13 -1
[iTC_CC_ATP-SwRS-0123] If the BeaconMessageReceive is True, the default message is judged by LockedBeaconMsgByteand ATP set the BeaconMessage.DefaultMessage; if there is no new beacon read, it keeps unchanged.    BeaconMessageReceive ; True ; default message ; LockedBeaconMsgByte ; BeaconMessage.DefaultMessage ; ATP  ; unchanged    <variable> <constant> <message> <variable> <variable> <system> <state>    1 2 0 ; 2 6 3 ; 0 1 2 ; 5 1 4 ; 6 1 4    if (Initialization) <variable_4> = False elif (<variable_0> (k))  <variable_4> (k) = <variable_3> [DEFAULT_MESSAGE_BIT] else:  <variable_4> = <variable_4>(k-1)    4 0 3 7 -1
[iTC_CC_ATP-SwRS-0165] TeethCounter used as the odometer cog value in one deferred task, which is the difference of the CogCounter in the last interrupt of adjacent cycle. The calculation of the TeethCounter shall consider the installation direction of the odometer and the register range of the CogCounter. NOTES: TeethCounter is a signed value. If TeethCounter greater than 0, then means the odometer rotating toward to the train END_1 direction; other hand, if it less than 0, then means the odometer rotating toward to the END_2.    TeethCounter ; odometer cog value ; CogCounter ; adjacent cycle ; 0 ; END_1 ; END_2    <variable> <otheritem> <variable> <otheritem> <constant> <statevariable> <statevariable>    0 4 1 ; 2 0 3 ; 0 10 4 ;  5 2 1; 6 2 1    <variable_0> (k) = <variable_0> (k-1) + (IdenticalLockedOdometer[ATP_INTERRUPT_NB - 1].<variable_2> (k) - IdenticalLockedOdometer[ATP_INTERRUPT_NB - 1].<variable_2> (k-1)) * ATPsetting.CCcoreOdoCogIncreasing[CoreId]    0 2 7 -1
[iTC_CC_ATP-SwRS-0166] If a beacon with top-loc received in this cycle, ATP shall record the cog position of the interrupt when and just before the top-loc happen: CogPositionBeforeTopLoc, the CogCounter in the interrupt just before the top-loc happen; CogPositionAfterTopLoc, the CogCounter in the interrupt when the top-loc happen. Which, i means the interrupt received top-loc signal.    beacon with top-loc ; this cycle ; cog position ; CogPositionBeforeTopLoc ; CogCounter ; CogPositionAfterTopLoc ; ATP    <beacon> <otheritem> <otheritem> <variable> <variable> <variable> <system>    0 0 1 ; 6 1 2 ; 3 4 4 ; 5 4 4 ; 3 7 5    <variable_3> (k) = TeethCounter(k-1) + ((IdenticalLockedOdometer[i-1].<variable_4> (k) - IdenticalLockedOdometer[ATP_INTERRUPT_NB-1].<variable_4> (k-1)) * ATPsetting.CCcoreOdoCogIncreasing[CoreId]))
<variable_5>(k) = TeethCounter(k-1) + ((IdenticalLockedOdometer[i].<variable_4> (k) - IdenticalLockedOdometer[ATP_INTERRUPT_NB-1].<variable_4> (k-1)) * ATPsetting.CCcoreOdoCogIncreasing[CoreId]))    3 4 5 10 11 12 7 -1
[iTC_CC_ATP-SwRS-0171] Wheel shall consider safely stopped WheelStopped at cycle k if the following conditions are fulfilled: sensors test has been performed, and at least one sensor out of three sensors C1, C2, C3 has detected expected sequence, and at least one sensor out of three sensors C1, C2, C3 has not detected expected sequence, and sensors test result combination on three sensors C1, C2, C3 has not changed between cycle k-1 and k.     WheelStopped ; cycle k ; C1 ; C2 ; C3 ; cycle k-1    <variable><cycle> <otheritem> <otheritem> <otheritem> <cycle>    0 2 1 ; 2 7 3 ; 2 7 4 ; 3 7 4 ; 2 1 0 ; 3 1 0 ; 4 1 0 ; 0 2 5    if (SensorTestPerformed(k) == True) <variable_0> (k) = ((UnconsistentSensorTest(k) == False) and (SensorSequenceDetected_1 = SensorSequenceDetected_1(k-1)) and (SensorSequenceDetected_2 = SensorSequenceDetected_2(k-1)) and (SensorSequenceDetected_3 = SensorSequenceDetected_3(k-1))) else:  <variable_0> = False    0 6 -1
[iTC_CC_ATP-SwRS-0172] At cycle k, WheelFilteredStopped shall change from False to True on raising edge of WheelStopped information, That is, if: WheelStopped information was False at cycle k-1,  and WheelStopped information was True at cycle k.  and then: LastStopCogPosition is assigned to TeethCounter, At cycle k, WheelFilteredStopped shall change from True to False, according following expression: the cog moved more than one cog.    cycle k ; WheelFilteredStopped ; False ; True ; WheelStopped ; cycle k-1 ; LastStopCogPosition ; TeethCounter    <cycle> <variable> <constant> <constant> <variable> <cycle> <variable> <variable>    0 6 1 ; 2 2 1 ; 3 2 1 ; 2 7 3 ;  2 2 4 ; 3 2 4 ; 4 1 1 ; 4 6 5 ; 4 6 0 ; 7 4 6    def <variable_1> (k): if (not <variable_4> (k-1) and not <variable_4> (k-1) and <variable_4> (k)): <variable_6> = <variable_7> (k)  return <constant_3> elif (<variable_1> (k-1) and not UnconsistentSensorTest(k) and abs(<variable_7> (k) -<variable_6> ) <= 1):  return<constant_3> else:  return<constant_2>    1 4 6 7 3 2 10 11 12 13 14 15 8 -1



























