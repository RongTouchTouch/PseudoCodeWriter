[iTC_CC_ATP-SwRS-0053] On initialization, ATP generates TrainType according to DataPlugContent.CCTrainType from the CC data plug.	ATP ; TrainType ; DataPlugContent.CCTrainType ; CC data plug	<system> <variable> <variable> <interface>	1 0 0  ; 2 0 3 ; 2 1 1	def <variable_1>(k): return <variable_2>	1 2 7 4 -1
[iTC_CC_ATP-SwRS-0054] On initialization, ATP generates CoreId according to DataPlugContent.CCCoreId read from the CC data plug.	ATP ; CoreId ;  DataPlugContent.CCCoreId ; CC data plug	<system> <variable> <variable> <interface>	1 0 0 ; 2 0 3 ; 2 1 1	def <variable_1>(k): return <variable_2>	1 2 7 4 -1
[iTC_CC_ATP-SwRS-0613] OtherCoreId, core id for CC on the distant cab.	OtherCoreId ;  CC ; cab	<variable> <system> <hardware>	0 0 1 ; 2 5 1	def <variable_0>(k): if (CoreId(k) is END_1):  return END_2 elif (CoreId(k) is END_2):  return END_1 else:  return None	3 -1 3 -1 3 -1
[iTC_CC_ATP-SwRS-0055] On initialization, ATP generates SubSystemId according to DataPlugContent.CC_SSID from the CC data plug.	ATP ; SubSystemId ; DataPlugContent.CC_SSID ; CC data plug	<system> <variable> <variable> <interface>	1 0 0 ; 2 0 3 ; 2 1 1	def <variable_1>(k): return <variable_2>	1 2 4 7 -1
[iTC_CC_ATP-SwRS-0059] After all above-mentioned information has corrected, and correspondingly, ATP will generate TrainKnown information. If TrainKnown considered as False, ATP shall set all output ports as restricted.	ATP ; TrainKnown ;  False ; output ports	<system> <variable> <constant> <interface>	1 0 0 ; 2 2 1 ; 0 5 3 ; 3 1 1	def <variable_1>(k): return ((TrainType(k) == ATPsetting.TrainTypeId) and (CoreId(k) is END_1 or CoreId(k) is END_2) and IdenticalVersionOfDualCPU(k))	1 4 -1
[iTC_CC_ATP-SwRS-0125] Through the communication with CCNV, ATP judges NonVitalRequest received from CCNV and generates NonVitalRequestReady If received a new message.	CCNV ; ATP ; NonVitalRequest ; NonVitalRequestReady	<system> <system> <variable> <variable>	0 3 1 ; 2 0 0 ; 3 0 1 ; 2 1 3	def <variable_3>(k): return Message.Exists(<variable_2>)	3 2 8 4 -1
[iTC_CC_ATP-SwRS-0126] ATOcontrolTimeValid stands for the effectiveness of CCNV message. If there is no updating CCNV message past the CCNV_VALIDITY_CYCLES, ATOcontrolTimeValid is set as False.	ATOcontrolTimeValid ; CCNV ; CCNV message ; CCNV_VALIDITY_CYCLES ; False	<variable> <system> <message> <statevariable> <constant>	0 6 2 ; 4 2 0 ; 2 1 0 ; 2 6 3	def <variable_0>(k): if (NonVitalRequestReady(k)):  <variable_0>= True  ATOcontrolTimer = 0 elif (ATOcontrolTimer(k-1) < <statevariable_3>):  ATOcontrolTimer = ATOcontrolTimer(k-1) + 1 else:  <variable_0>= <constant_4> return <variable_0>	0 3 4 7 5 -1
[iTC_CC_ATP-SwRS-0468] VIOM1VitalInputsReceived, ATP determines whether received a safety input message from VIOM1.	ATP ; safety input message ; VIOM1 ; VIOM1VitalInputsReceived	<system> <message> <interface><variable>	0 3 2 ; 1 0 2 ; 3 1 0	def <variable_3>(viomId, k): return Message.Received(VIOM1VitalInput(viomId), k)	3 4 -1
[iTC_CC_ATP-SwRS-0060] Through the communication, ATP gets the vital input message from VIOM1 and decides the time effectiveness and the correctness of the sequence of the message, which defined as VIOM1VitalInputsAvailable.	ATP ; VIOM1 ; time effectiveness ; correctness ; VIOM1VitalInputsAvailable ; vital input message	<system> <interface> <otheritem> <otheritem> <variable> <message>	0 3 1 ;  2 7 3 ; 0 1 2 ; 0 1 3 ; 4 4 5 ; 5 0 1	def <variable_4>(ViomId, k): return Message.Available(VIOM1VitalInputsReceived(ViomId, k), VIOM1VitalInput(ViomId).AtpLoopHour, VIOM_VALIDITY_TIME, VIOM1VitalInputsLastAge(ViomId, k-1), k)	4 6 -1
[iTC_CC_ATP-SwRS-0740] VIOM1VitalInputsLastAge, records the survival time of received vital inputs from VIOM1.	 survival time ; VIOM1 ; vital inputs ; VIOM1VitalInputsLastAge	<time> <interface> <otheritem> <variable>	0 0 1 ; 2 9 0 ; 3 4 0	def <variable_3>(ViomId, k): return Message.LastAge(VIOM1VitalInputsAvailable(ViomId, k), VIOM1VitalInput(ViomId).AtpLoopHour <variable_3>(ViomId, k-1), k)	3 4 -1
[iTC_CC_ATP-SwRS-0572] ATP records the latest cycle time information of VIOM in END_1 by the term LatestVIOM1LoopHourVIOM. In initialization, set LatestVIOM1LoopHourVIOM as the zero; If receiving an available VIOM1 message, or a new message and the previous one has invalid, ATP will set the related value of LatestVIOM1LoopHourVIOM as the viomLoopHour of the message. Otherwise, LatestVIOM1LoopHourVIOM keeps unchanged.	ATP ; cycle time ; VIOM ; END_1 ; LatestVIOM1LoopHourVIOM ; zero ; VIOM1 message ; viomLoopHour ; invalid	<system> <time> <interface> <statevariable> <variable> <constant> <message> <variable> <state>	1 0 2 ; 0 8 1 ; 4 8 1 ; 1 0 3 ; 5 2 4 ; 6 1 3 ; 7 1 4 ; 8 6 4	def <variable_4>(ViomId, k): if (VIOM1VitalInputsAvailable(k) or (not VIOM1VitalInputsValid(k-1) and VIOM1VitalInputsReceived(ViomId, k))):  return VIOM1VitalInput[ViomId].<variable_7>else:  return <variable_4>[ViomId](k-1)	4 7 15 9 -1
[iTC_CC_ATP-SwRS-0614] VIOM2VitalInputsReceived, ATP determines whether received a safety input message from VIOM2.	ATP ; safety input message ; VIOM2 ; VIOM2VitalInputsReceived	<system> <otheritem> <interface> <variable>	0 3 2 ; 1 0 2 ; 1 6 3	def <variable_3>(ViomId, k): return Message.Received(VIOM2VitalInput(ViomId), k)	3 4 -1
[iTC_CC_ATP-SwRS-0449] Through the communication, ATP gets the vital input message from VIOM2 and decides the time effectiveness and the correctness of the sequence of the message, which defined as VIOM2VitalInputsAvailable. During the calculation, the value i is either zero or one, which represents one of the two VIOM in the train END_2.	ATP ; VIOM2 ; time effectiveness ; correctness ; VIOM2VitalInputsAvailable ; zero ; one ; VIOM ; END_2 ; vital input message	<system> <interface> <otheritem> <otheritem> <variable> <constant> <constant> <interface> <statevariable> <message>	0 3 1 ;  2 7 3 ; 0 1 2 ; 0 1 3 ; 4 4 9 ; 9 0 1 ; 7 0 8 ; 5 1 7 ; 6 1 7	def <variable_4>(ViomId, k): return Message.Available(VIOM2VitalInputsReceived(ViomId, k), VIOM2VitalInput(ViomId).AtpLoopHour, VIOM_VALIDITY_TIME, VIOM2VitalInputsLastAge(ViomId, k-1), k)	4 10 -1
[iTC_CC_ATP-SwRS-0741] VIOM2VitalInputsLastAge, records the survival time of received vital inputs from VIOM2.	survival time ; vital inputs ; VIOM2 ; VIOM2VitalInputsLastAge	<time> <otheritem> <interface> <variable>	1 9 0 ; 0 0 2 ; 3 4 0	def <variable_3>(viomId, k): return Message.LastAge(VIOM2VitalInputsAvailable(viomId, k) VIOM2VitalInput(viomId).AtpLoopHour, <variable_3>(viomId, k-1), k)	3 4 -1
[iTC_CC_ATP-SwRS-0573] ATP records the latest cycle time information of VIOM in END_2 by the term LatestVIOM2LoopHourVIOM. In initialization, set LatestVIOM2LoopHourVIOM as the zero; If receiving an available VIOM1 message, or a new message and the previous one has invalid, ATP will set the related value of LatestVIOM2LoopHourVIOM as the viomLoopHour of the message. Otherwise, LatestVIOM2LoopHourVIOM keeps unchanged.	ATP ; cycle time ; VIOM ; END_2 ; LatestVIOM2LoopHourVIOM ; zero ; VIOM1 message ; viomLoopHour ; invalid	<system> <time> <interface> <statevariable> <variable> <constant> <message> <variable> <state>	1 0 2 ; 0 8 1 ; 4 8 1 ; 1 0 3 ; 5 2 4 ; 6 1 3 ; 7 1 4 ; 8 4 6	defLatestVIOM2LoopHourVIOM<variabel_4>(ViomId, k): if (VIOM2VitalInputsAvailable(k) or (not VIOM2VitalInputsValid(k-1) and VIOM2VitalInputsReceived(ViomId, k))):  return VIOM2VitalInput[ViomId].<variable_7> else:  return<variabel_4>[ViomId](k-1)	4 7 15 9 -1
[iTC_CC_ATP-SwRS-0538] VIOM1VitalInputsValid, ATP determines whether the vital inputs message from VIOM1 valid.	ATP ; vital inputs message ; VIOM1 ; VIOM1VitalInputsValid ; valid	<system> <message> <interface> <variable> <state>	1 0 2 ; 0 3 2 ; 1 6 3 ; 3 6 4	def <variable_3>(k): return (Message.Valid(VIOM1VitalInput(1).AtpLoopHour, VIOM_VALIDITY_TIME) or Message.Valid(VIOM1VitalInput(2).AtpLoopHour, VIOM_VALIDITY_TIME))	3 5 -1
[iTC_CC_ATP-SwRS-0539] VIOM2VitalInputsValid, ATP determines whether the vital inputs message from VIOM2 valid.	ATP ; vital inputs message ; VIOM2 ; VIOM2VitalInputsValid ; valid	<system> <message> <interface> <variable> <state>	1 0 2 ; 0 3 2 ; 1 6 3 ; 3 6 4	def <variable_3>(k): return (Message.Valid(VIOM2VitalInput(1).AtpLoopHour, VIOM_VALIDITY_TIME) or Message.Valid(VIOM2VitalInput(2).AtpLoopHour, VIOM_VALIDITY_TIME))	3 5 -1
[iTC_CC_ATP-SwRS-0075] CoupledByEnd1 or CoupledByEnd2 shows that both ends of train connect with other trains. If the project is not configured with the capture of coupling input, it is certain that the train does not connect with other trains.	CoupledByEnd1 ;  CoupledByEnd2 ; ends of train ; coupling input	<variable> <variable> <hardware> <otheritem>	0 7 1 ; 0 6 2 ; 1 6 2	def <variable_0>(k): return Offline.GetCoupledByEnd1(k) def <variable_1>(k): return Offline.GetCoupledByEnd2(k)	0 1 5 4 -1
[iTC_CC_ATP-SwRS-0144] ATPtime stands for the ATP loop hour of this train END. Based on CoreId, ATP initialize ATPtime as the initiative value of END_1 or END_2; If the value exceeds the maximum loop hour, ATP shall set it as the initiative value; Otherwise, add one for each cycle.	ATPtime ;  ATP ; ATP loop hour ; train END ; END ; CoreId ;  END_1 ; END_2 ;  maximum loop hour ; cycle ; one	<variable> <system> <time> <hardware> <statevariable> <variable> <statevarable> <statevariable> <time> <otheritem> <constant>	0 4 2 ; 2 0 3 ; 5 1 0 ; 0 0 1 ; 6 7 7 ; 6 2 0 ; 7 2 0 ; 1 6 0 ; 6 10 8 ; 7 10 8 ; 8 1 0	def ATPtime(k): if (CoreId(k) is END_1):  if (Initialization):   return CC1_INIT_TIME  elif (<variable_0>(k-1) >= CC1_MAX_TIME):   return CC1_INIT_TIME  else:   return <variable_0>(k-1) + <constant_10> else:  if (Initialization):   return CC2_INIT_TIME  elif (<variable_0>(k-1) >= CC2_MAX_TIME):   return CC2_INIT_TIME  else:   return <variable_0>(k-1) + <constant_10>	0 10 11 -1
[iTC_CC_ATP-SwRS-0615] OtherATPmessageReceived, the message transmitted from the distant ATP in the other END shall be protected by checking words. And before using the information, ATP shall verify the check words.	OtherATPmessageReceived ;  ATP ; the other END ; check words	<variable> <system> <hardware> <otheritem>	0 6 3	def <variable_0>(k): return Message.Received(OtherCCsynchroReport,k)	0 4 -1
[iTC_CC_ATP-SwRS-0078] OtherATPmessageAvailable, ATP shall judge the effectiveness of message from the redundant ATP, shown as following pseudo-codes:	OtherATPmessageAvailable ; ATP ; effectiveness ; redundant ATP	<variable> <system> <otheritem> <system>	0 6 2	def <variable_0>(k): return Message.Available(OtherATPmessageReceived(k), OtherCCsynchroReport.LatestTimeOtherCore, OTHER_ATP_VALIDITY_TIME, LastOtherATPmessageAge(k-1), k)	0 4 -1
[iTC_CC_ATP-SwRS-0540] OtherATPmessageValid represents the effectiveness of the messages from redundant ATP. If this message is invalid, ATP will set OtherATPmessageValid as False; otherwise, it is set as True.	OtherATPmessageValid ; effectiveness ; invalid ; False ; True	<variable> <otheritem> <state> <constant> <constant>	3 2 0 ; 4 2 0 ; 0 6 1	def <variable_0>(k): return Message.Valid(OtherCCsynchroReport.LatestTimeOtherCore, OTHER_ATP_VALIDITY_TIME, k)	0 5 -1
[iTC_CC_ATP-SwRS-0081] The OtherATPminTime stands for the local ATP maintained minimum time of the redundant ATP. The setting rule is as following: In initialization, ATP set the OtherATPminTime as default value based on the CoreId of the redundant ATP. Or else:, if the updating message from the new redundant ATP in this cycle is available, ATP will update OtherATPminTime as the current time in the message. Or else:, if the redundant ATP message is still effective, ATP will add one in the OtherATPminTime until it is out of bound, and set is as initialization value. Or else:, If the received a new redundant ATP message, but it was not available, ATP shall update OtherATPminTime as in the message. Otherwise, accumulate OtherATPminTime.	OtherATPminTime ; ATP ; maintained minimum time ; redundant ATP ; CoreId ; updating message ; available ; effective ; one ; out of bound ; not available ; redundant ATP message	<variable> <system> <time> <system> <variable> <message> <state> <state> <constant> <state> <state> <message>	0 4 2 ; 2 0 3 ; 4 1 0 ; 4 0 3 ; 5 1 0 ; 6 2 5 ; 11 1 0 ; 7 2 11 ; 0 6 9 ; 0 6 8 ; 9 2 11	if (<variable_4>== END_1) if (Initialization)   <variable_0> = CC2_INIT_TIME elif ((OtherATPmessageAvailable(k) == True) or ((OtherATPmessageValid(k) == False) and Exists(OtherCCsynchroReport)))   <variable_0>= OtherCCsynchroReport.CurrentTime else:  if (<variable_0>(k-1) >= CC2_MAX_TIME)   <variable_0>= CC2_INIT_TIME  else:   <variable_0>= <>variable_0(k-1) + <constant_8> else:  if (Initialization)   <variable_0>= CC1_INIT_TIME  elif ((OtherATPmessageAvailable(k) == True) or ((OtherATPmessageValid(k) == False) and Exists(OtherCCsynchroReport))   <variable_0>= OtherCCsynchroReport.CurrentTime  else:   if (<variable_0>(k-1) >= CC1_MAX_TIME)  <variable_0>= CC1_INIT_TIME   else:  <variable_0>= <variable_)>(k-1) + <constant_8>	4 0 8 15 22 12 -1
[iTC_CC_ATP-SwRS-0083] The OtherATPmaxTime stands for the local ATP maintained maximum time of the redundant ATP. The rules to update OtherATPmaxTime are similar with OtherATPminTime except that when received a new message from the redundant ATP, the OtherATPmaxTime shall add the maximum transmission delay in network.	OtherATPmaxTime ; maintained maximum time ; ATP ; redundant ATP ; OtherATPminTime ; maximum transmission delay	<variable> <time> <system> <system> <variable> <otheritem>	0 4 1 ; 1 0 3 ; 4 1 0 ; 0 6 5	if (CoreId == END_1) if (Initialization) <variable_0>= CC2_INIT_TIME elif ((OtherATPmessageAvailable(k) == True) or ((OtherATPmessageValid(k) == False) and Exists(OtherCCsynchroReport)))  <variable_0>= OtherCCsynchroReport.CurrentTime + LoopHourModularSub(ATPtime(k), OtherCCsynchroReport.LatestTimeOtherCore) else  if (<variable_0>(k-1) >= CC2_MAX_TIME)   <variable_0>= CC2_INIT_TIME  else:   <variable_0>= <variable_0>(k-1) + 1 else:  if (Initialization)   <variable_0>= CC1_INIT_TIME  elif ((OtherATPmessageAvailable(k) == True) or ((OtherATPmessageValid(k) == False) and Exists(OtherCCsynchroReport)))   <variable_0>= OtherCCsynchroReport.CurrentTime + LoopHourModularSub(ATPtime(k), OtherCCsynchroReport.LatestTimeOtherCore)  else:   if (<variable_0>(k-1) >= CC1_MAX_TIME)  <variable_0>= CC1_INIT_TIME   else:  <variable_0>= <variable_0>(k-1) + 1	0 6 -1
[iTC_CC_ATP-SwRS-0080] OtherATP, parse and store messages from the distant ATP. In initialization or the message has expired, set all variables as default value; when new message available, set the corresponding value from the new message; otherwise, remain unchanged.	OtherATP ; distant ATP ;  expired ;  default value ; available ;  unchanged	<variable> <system> <state> <otheritem> <state> <state>	0 6 1 ; 3 1 0 ; 2 1 3 ; 4 1 5 ; 4 1 0 ; 2 7 5	def <variable_0>(k): if (Initialization or (not OtherATPmessageValid(k))):  <variable_0>.LatestTimeOtherCore = INVALID_LOOP_HOUR  <variable_0>.CoreId = None  <variable_0>.BeaconId = None  <variable_0>.EnableDoorOpening_A = False  <variable_0>.EnableDoorOpening_B = False <variable_0>.PsdManagerOpeningOrder = False  <variable_0>.PsdIdSide_A = None  <variable_0>.PsdValiditySide_A = None  <variable_0>.PsdClosedSide_A = False  <variable_0>.PsdIdSide_B = None <variable_0>.PsdValiditySide_B = None <variable_0>.PsdClosedSide_B = False  <variable_0>.ZcVersion = None  <variable_0>.LocatedOnKnownPath = False  <variable_0>.LocatedWithMemLocation = False  <variable_0>.Location.Ext2 = None  <variable_0>.Location.Uncertainty = None  <variable_0>.Location.Ext1 = None  <variable_0>.SleepZoneId = None  <variable_0>.SleepZoneVersion = None  <variable_0>.MotionSinceLastReloc = None  <variable_0>.MotionSinceMemLoc = None  <variable_0>.TrainFilteredStopped = False  <variable_0>.SafetyParameterVersion = None  <variable_0>.SafetyApplicationVersion = None  <variable_0>.CC_SSID = None  <variable_0>.OverlapExpired = False elif (OtherATPmessageAvailable(k)): <variable_0>.LatestTimeOtherCore = OtherCCsynchroReport.LatestTimeOtherCore(k) <variable_0>.CoreId = OtherCCsynchroReport.CoreId  <variable_0>.BeaconId = OtherCCsynchroReport.BeaconId  <variable_0>.EnableDoorOpening_A = OtherCCsynchroReport.EnableDoorOpening_A  <variable_0>.EnableDoorOpening_B = OtherCCsynchroReport.EnableDoorOpening_B  <variable_0>.PsdManagerOpeningOrder = OtherCCsynchroReport.PsdManagerOpeningOrder  <variable_0>.PsdIdSide_A = OtherCCsynchroReport.PsdIdSide_A  <variable_0>.PsdValiditySide_A = OtherCCsynchroReport.PsdValiditySide_A  <variable_0>.PsdClosedSide_A = OtherCCsynchroReport.PsdClosedSide_A  <variable_0>.PsdIdSide_B = OtherCCsynchroReport.PsdIdSide_B  <variable_0>.PsdValiditySide_B = OtherCCsynchroReport.PsdValiditySide_B  <variable_0>.PsdClosedSide_B = OtherCCsynchroReport.PsdClosedSide_B  <variable_0>.ZcVersion = OtherCCsynchroReport.ZcVersion  <variable_0>.LocatedOnKnownPath = OtherCCsynchroReport.LocatedOnKnownPath  <variable_0>.LocatedWithMemLocation = OtherCCsynchroReport.LocatedWithMemLocation  <variable_0>.Location.Ext2 = OtherCCsynchroReport.Location.Ext2  <variable_0>.Location.Uncertainty = OtherCCsynchroReport.Location.Uncertainty  <variable_0>.Location.Ext1 = OtherCCsynchroReport.Location.Ext1  <variable_0>.SleepZoneId = OtherCCsynchroReport.SleepZoneId  <variable_0>.SleepZoneVersion = OtherCCsynchroReport.SleepZoneVersion  <variable_0>.MotionSinceLastReloc = OtherCCsynchroReport.MotionSinceLastReloc	0 6 -1
[iTC_CC_ATP-SwRS-0067] BlockModeUsed represents that either of train end chooses BM mode.	BlockModeUsed ; BM mode ; train end	<variable> <mode> <hardware>	0 6 2	def <variable_0>(k): return Offline.GetBlockModeUsed(k)	0 3 -1
[iTC_CC_ATP-SwRS-0066] The status of BMvariantValidWhileTemporallyValid shows whether it is in the BM mode.	BMvariantValidWhileTemporallyValid ; BM mode	<variable> <mode>	0 6 1	def <variable_0>(k): return Offline.GetBMvariantValidWhileTemporallyValid(k)	0 3 -1
[iTC_CC_ATP-SwRS-0146] BeaconVariantsUpdating used to determine ATP whether to update the BM variants in this cycle. If all the following conditions are fulfilled, ATP shall set BeaconVariantsUpdating as True: The current operational mode is BLOCK MODE; And train moved and ATP received a BM beacon in this cycle; And the train is either not localized, or the direction of the BM variants is as same as the orientation of the train front end. Otherwise, ATP shall set BeaconVariantsUpdating as False.	BeaconVariantsUpdating ; ATP ; BM variants ; fulfilled ; True ; BLOCK MODE ; BM beacon ; not localized ; direction ; train front end ; False	<variable> <system> <otheritem> <state> <constant> <statevariable> <beacon> <state> <otheritem> <hardware> <constant>	0 1 2 ; 1 1 2 ; 4 2 0 ; 3 1 0 ; 10 2 0 ; 9 9 8 ; 5 7 7	def <variable_0>(k): return (BMvariantValidWhileTemporallyValid(k) and BeaconMessageReceive(k) and TrackMap.IsBmBeacon(BeaconMessage.ID) and not TrainFilteredStopped(k) and (not TrainLocalized(k-1) or (TrackMap.BmBeaconDirection(BeaconMessage.ID)== TrainFrontOrientation(k-1))))	0 11 -1
[iTC_CC_ATP-SwRS-0148] UsedBMbeaconId records the used BM variants came from BM beacon: When one of the following conditions fulfilled, ATP clear the UsedBMbeaconId: initialization, the BLOCK MODE variant is not temporally valid, the direction of the used BM beacon is not as same as train front orientation, the train is not localized. Or else:, when received a valid BM beacon, ATP update UsedBMbeaconId; Otherwise, keep this value unchanged.	UsedBMbeaconId ; BM variants ; BM beacon ; ATP ; BLOCK MODE ; not temporally valid ; direction ; train front orientation ; not localized ; unchanged ; fullfilled	<variable> <otheritem> <beacon> <system> <statevariable> <state> <otheritem><otheritem> <state> <state> <state>	0 8 1 ; 1 0 2 ; 10 1 0 ; 3 1 0 ; 5 2 4 ; 2 9 6 ; 6 10 7 ; 9 1 0 ; 8 1 0	def <variable_0>(k): if (BeaconVariantsUpdating(k)):  return BeaconMessage.Id elif (Initialization or not BMvariantValidWhileTemporallyValid(k) or (TrainLocalized(k-1) and (TrackMap.BmBeaconDirection(<variable_0>(k-1)) is not TrainFrontOrientation(k-1))) or (TrainLocalized(k-1) and not TrainLocalized(k))):  return None else:  return <variable>(k-1)	0 11 -1
[iTC_CC_ATP-SwRS-0093] SameVersionWithDistantCore, the local ATP shall compare the information from the redundant ATP to ensure the consistency, which includes versions of vital software, project configuration data and the track map.	local ATP ; redundant ATP ; versions ; project configuration data ; track map ; SameVersionWithDistantCore	<system> <system> <otheritem> <otheritem> <otheritem> <variable>	0 3 1 ; 2 7 3 ; 2 7 4 ; 3 7 4	def <variable_5>(k): if (OtherATPmessageValid(k) and (OtherATP.SafetyParameterVersion == ATPsetting.SafetyParameterVersion) and (OtherATP.SafetyApplicationVersion == SafeApplicationVersion)):  for ZcId in range(0, MAX_ZC_NB):   if (OtherATP.ZcVersion[ZcId] != TrackMap.ZC[ZcId].Version):  return False   else:  continue  else:   return True else:  return False	5 6 -1
[iTC_CC_ATP-SwRS-0105] ZCmessageReady represents an available EOA and variants message from ZC received in this cycle.	ZCmessageReady ; EOA ; ZC ; variants message	<variable> <message> <interface> <message>	0 4 1 ; 0 4 3 ; 1 7 3 ; 3 0 2	def <variable_0>(k): return (Message.Available(EOAReportReceived(k), EOA_Report.CcLoopHour, ATPsetting.EOAvalidityTime, LastEOAReportAge(k-1), k) and (VersionAuthorizedByLC(SSIDofZC, k)) and (Message.ReplyLocalCC(EOA_Report.CcLoopHour) or SameVersionWithDistantCore(k)))	0 4 -1
[iTC_CC_ATP-SwRS-0108] LastEOAReportAge represents the value calculated by current ATP time minus the previous loc-report number and the EOA consuming time in ZC.	LastEOAReportAge ; current ATP time ; previous loc-report number ; EOA consuming time ; ZC	<variable> <time> <otheritem> <time> <interface>	1 1 0 ; 2 1 0 ; 3 1 0; 1 7 2; 1 7 3 ; 2 7 3 ;3 0 4	def <variable_0>(k): return Message.LastAge(ZCmessageReady(k), EOA_Report.CcLoopHour, LastEOAReportAge(k-1), k)	0 5 -1
[iTC_CC_ATP-SwRS-0106] EOAgroundAge stands for the number of CC cycle when receiving the EOA information.	EOAgroundAge ; number of CC cycle ; EOA information	<variable> <otheritem> <message>	0 4 1 ; 2 1 0	def <variable_0>(k): if (Initialization):  <variable_0>(.WithoutSpacing = REPORT_AGE_MAX  <variable_0>.Classic = REPORT_AGE_MAX elif (ZCmessageReady(k)):  <variable_0>.WithoutSpacing = (round.ceil ((EOA_Report.MessageContainerCreationTime - EOA_Report.WithoutSpacingEoaCreationTime) * SYNCHRODATE_TIME_UNIT_MS / ATP_CYCLE_TIME_MS))  <variable_0>.Classic = round.ceil((EOA_Report.MessageContainerCreationTime - EOA_Report.EoaCreationTime) * SYNCHRODATE_TIME_UNIT_MS / ATP_CYCLE_TIME_MS) else:  <variable_0>=<variable_0>(k-1) return <variable_0>	0 3 -1
[iTC_CC_ATP-SwRS-0109] VariantGroundAge shows the survival time of the variants in ZC.	VariantGroundAge ; survival time ; variants in ZC	<variable> <time> <otheritem>	0 4 1 ; 2 9 1	def <variable_0>(lineSec, k): <variable_0> = round.ceil((EOA_Report.MessageContainerCreationTime - VariantReport(lineSec).CreationTime) * SYNCHRODATE_TIME_UNIT_MS / ATP_CYCLE_TIME_MS) return <variable_0>	0 3 -1
[iTC_CC_ATP-SwRS-0150] CBTCvariantValue, ATP shall maintain the validation of CBTC variants message from ZC. if the validation timeout, ATP should set all CBTC variants to restrictive state.	ATP ; validation ; CBTC variants message ; timeout ; restrictive state ; ZC ; CBTCvariantValue	<system> <state> <message> <state> <state> <interface> <variable>	2 9 1 ; 0 1 2 ; 2 0 5 ; 3 1 6 ; 4 2 2 ; 3 1 2	def <variable_6>(Variant, k): if (ReceivedVariantReport(Variant.LineSec.Id, k).ValidityTime > ATPtime(k)):  return ReceivedVariantReport(Variant.LineSec.Id, k).Status(Variant.LineSec.Index) else:  return False	6 7 -1
[iTC_CC_ATP-SwRS-0118] BeaconCount represents the accumulated number of received Top-loc signal from power on to current cycle.	BeaconCount ; Top-loc signal ; power on ; current cycle	<variable> <otheritem> <state> <state>	2 7 3 ; 1 1 0 ; 1 0 2 ; 1 0 3	if (Initialization)  <variable_0>= 0 else:  <variable_0>= LockedTopLocCounter(k) + BeaconCount(k-1)	0 4 -1
[iTC_CC_ATP-SwRS-0121] If the status of BeaconMessageReceive is True, the BeaconMessage.ID is obtained by LockedBeaconMsgByte; Otherwise, keep it unchanged.	BeaconMessageReceive ; True ; BeaconMessage.ID ; LockedBeaconMsgByte ; unchanged	<variable> <constant> <variable> <variable> <state>	1 2 0 ; 3 4 2 ; 1 1 3 ; 4 2 3 ; 0 1 3	if (Initialization) <variable_2> = 0 elif (<variable_0> (k)) <variable_2> = <variable_3> [BEACON_ID_BITS] else: <variable_2> = <variable_2> (k-1)	2 0 3 7 10 5 -1
[iTC_CC_ATP-SwRS-0122] If the BeaconMessageReceive is True, the variants is come from LockedBeaconMsgByteand ATP set as BeaconMessage.Variants[MAX_BM_VARIANT_NB]; if there is no beacon read at the end of cycle, there is no changes. BM_VARIANTS_BIT_0...BM_VARIANTS_BIT_15 represents the index of BM beacon variants defined in [REF4].	BeaconMessageReceive ; True ; LockedBeaconMsgByte ; BeaconMessage.Variants ; BM_VARIANTS_BIT_0 ; .BM_VARIANTS_BIT_15 ; BM beacon variants ; [REF4] ; [MAX_BM_VARIANT_NB]	<variable> <constant> <variable> <variable> <statevariable> <statevariable> <otheritem> <otheritem> <statevariable>	1 2 0 ; 0 1 2 ; 3 2 2 ;  4 7 5 ; 4 4 6 ; 5 4 6 ; 6 0 7	if (Initialization) <variable_3> = {0,..,0} elif (<variable_0> (k))  <variable_3> (k) = {<variable_2> [<statevariable_4> ],  ...,  <variable_2> [<statevariable_5> } else:  <variable_3> = <variable_3> (k-1)	3 0 2 4 5 11 12 13 -1
[iTC_CC_ATP-SwRS-0123] If the BeaconMessageReceive is True, the default message is judged by LockedBeaconMsgByteand ATP set the BeaconMessage.DefaultMessage; if there is no new beacon read, it keeps unchanged.	BeaconMessageReceive ; True ; default message ; LockedBeaconMsgByte ; BeaconMessage.DefaultMessage ; ATP  ; unchanged	<variable> <constant> <message> <variable> <variable> <system> <state>	1 2 0 ; 2 6 3 ; 0 1 2 ; 5 1 4 ; 6 1 4	if (Initialization) <variable_4> = False elif (<variable_0> (k))  <variable_4> (k) = <variable_3> [DEFAULT_MESSAGE_BIT] else:  <variable_4> = <variable_4>(k-1)	4 0 3 7 -1
[iTC_CC_ATP-SwRS-0165] TeethCounter used as the odometer cog value in one deferred task, which is the difference of the CogCounter in the last interrupt of adjacent cycle. The calculation of the TeethCounter shall consider the installation direction of the odometer and the register range of the CogCounter. NOTES: TeethCounter is a signed value. If TeethCounter greater than 0, then means the odometer rotating toward to the train END_1 direction; other hand, if it less than 0, then means the odometer rotating toward to the END_2.	TeethCounter ; odometer cog value ; CogCounter ; adjacent cycle ; 0 ; END_1 ; END_2	<variable> <otheritem> <variable> <otheritem> <constant> <statevariable> <statevariable>	0 4 1 ; 2 0 3 ; 0 10 4 ;  5 2 1; 6 2 1	<variable_0> (k) = <variable_0> (k-1) + (IdenticalLockedOdometer[ATP_INTERRUPT_NB - 1].<variable_2> (k) - IdenticalLockedOdometer[ATP_INTERRUPT_NB - 1].<variable_2> (k-1)) * ATPsetting.CCcoreOdoCogIncreasing[CoreId]	0 2 7 -1
[iTC_CC_ATP-SwRS-0166] If a beacon with top-loc received in this cycle, ATP shall record the cog position of the interrupt when and just before the top-loc happen: CogPositionBeforeTopLoc, the CogCounter in the interrupt just before the top-loc happen; CogPositionAfterTopLoc, the CogCounter in the interrupt when the top-loc happen. Which, i means the interrupt received top-loc signal.	beacon with top-loc ; this cycle ; cog position ; CogPositionBeforeTopLoc ; CogCounter ; CogPositionAfterTopLoc ; ATP	<beacon> <otheritem> <otheritem> <variable> <variable> <variable> <system>	0 0 1 ; 6 1 2 ; 3 4 4 ; 5 4 4 ; 3 7 5	<variable_3> (k) = TeethCounter(k-1) + ((IdenticalLockedOdometer[i-1].<variable_4> (k) - IdenticalLockedOdometer[ATP_INTERRUPT_NB-1].<variable_4> (k-1)) * ATPsetting.CCcoreOdoCogIncreasing[CoreId])) <variable_5>(k) = TeethCounter(k-1) + ((IdenticalLockedOdometer[i].<variable_4> (k) - IdenticalLockedOdometer[ATP_INTERRUPT_NB-1].<variable_4> (k-1)) * ATPsetting.CCcoreOdoCogIncreasing[CoreId]))	3 4 5 10 11 12 7 -1
[iTC_CC_ATP-SwRS-0171] Wheel shall consider safely stopped WheelStopped at cycle k if the following conditions are fulfilled: sensors test has been performed, and at least one sensor out of three sensors C1, C2, C3 has detected expected sequence, and at least one sensor out of three sensors C1, C2, C3 has not detected expected sequence, and sensors test result combination on three sensors C1, C2, C3 has not changed between cycle k-1 and k.	WheelStopped ; cycle k ; C1 ; C2 ; C3 ; cycle k-1	<variable><cycle> <otheritem> <otheritem> <otheritem> <cycle>	0 2 1 ; 2 7 3 ; 2 7 4 ; 3 7 4 ; 2 1 0 ; 3 1 0 ; 4 1 0 ; 0 2 5	if (SensorTestPerformed(k) == True) <variable_0> (k) = ((UnconsistentSensorTest(k) == False) and (SensorSequenceDetected_1 = SensorSequenceDetected_1(k-1)) and (SensorSequenceDetected_2 = SensorSequenceDetected_2(k-1)) and (SensorSequenceDetected_3 = SensorSequenceDetected_3(k-1))) else:  <variable_0> = False	0 6 -1
[iTC_CC_ATP-SwRS-0172] At cycle k, WheelFilteredStopped shall change from False to True on raising edge of WheelStopped information, That is, if: WheelStopped information was False at cycle k-1,  and WheelStopped information was True at cycle k.  and then: LastStopCogPosition is assigned to TeethCounter, At cycle k, WheelFilteredStopped shall change from True to False, according following expression: the cog moved more than one cog.	cycle k ; WheelFilteredStopped ; False ; True ; WheelStopped ; cycle k-1 ; LastStopCogPosition ; TeethCounter	<cycle> <variable> <constant> <constant> <variable> <cycle> <variable> <variable>	0 6 1 ; 2 2 1 ; 3 2 1 ; 2 7 3 ;  2 2 4 ; 3 2 4 ; 4 1 1 ; 4 6 5 ; 4 6 0 ; 7 4 6	def <variable_1> (k): if (not <variable_4> (k-1) and not <variable_4> (k-1) and <variable_4> (k)): <variable_6> = <variable_7> (k)  return <constant_3> elif (<variable_1> (k-1) and not UnconsistentSensorTest(k) and abs(<variable_7> (k) -<variable_6> ) <= 1):  return<constant_3> else:  return<constant_2>	1 4 6 7 3 2 10 11 12 13 14 15 8 -1
[iTC_CC_ATP-SwRS-0173] MaxCountCogsRunInCycleExceeded，ATP shall detect whether the cog number counted in adjacent interrupt is greater than the default maximum cog number on cycle or on interrupt.	ATP ; cog number ; default maximum cog number ; MaxCountCogsRunInCycleExceeded	<system> <otheritem> <otheritem> <variable>	0 1 1 ; 1 10 2 ; 3 6 1	def <variable_3> (k): if (abs(IdenticalLockedOdometer[ATP_INTERRUPT_NB-1].CogCounter(k) - IdenticalLockedOdometer[ATP_INTERRUPT_NB-1].CogCounter(k-1)) > ATPsetting.OdoMaxCogOnCycle):  return True else:  for i in range(ATP_INTERRUPT_NB-1):   if (abs(IdenticalLockedOdometer[i].CogCounter- IdenticalLockedOdometer[i+1].CogCounter)> ATPsetting.OdoMaxCogOnIntrrupt):	return True  else:   continue return False	0 4 -1
[iTC_CC_ATP-SwRS-0176] If OdometerState is NOT_INITIALIZED at cycle k, and if wheel detected stopped at cycle k, then WheelMinimumMovement and WheelMaximumMovement shall be set to zero.	OdometerState ; NOT_INITIALIZED ; cycle k ; WheelMinimumMovement ; WheelMaximumMovement ; zero	<variable> <statevariable> <cycle> <variable> <variable> <constant>	1 2 0 ; 1 2 2 ; 5 2 4 ; 5 2 3 ; 3 7 4 ; 0 1 3 ; 0 1 4	if (<variable_0> (k) == <statevariable_1>) if (WheelFilteredStopped(k) == True)) <variable_3> = <constant_5>  <variable_4> = <constant_5> else: <variable_3> = ATPsetting.MaxMotionPerCycle  <variable_3> = ATPsetting.MaxMotionPerCycle	0 1 3 5 4 7 9 10 11 12 13 6 -1
[iTC_CC_ATP-SwRS-0177] At cycle k, ATP shall consider that OdometerState changes from NOT_INITIALIZED to WAITING_COG_POSITION_CODE_READY if: a falling edge is detected on WheelFilteredStopped information, and sensors test is consistent at cycle k and was consistent at cycle k-1,	cycle k ; ATP ; OdometerState ; NOT_INITIALIZED ; WAITING_COG_POSITION_CODE_READY ; WheelFilteredStopped ; cycle k-1	<cycle> <system> <variable> <statevariable> <statevariable> <variable> <cycle>	3 7 4 ; 3 2 2 ; 4 2 2 ; 0 6 3 ; 0 6 4 ; 1 1 2	if ((<variable_2>(k-1) =  <statevariable_3> ) and (not <variable_5> (k) and not UnconsistentSensorTest(k)) and (<variable_5> (k-1)  <variable_2> =  <statevariable_4>	2 3 5 4 8 9 10 7 -1
[iTC_CC_ATP-SwRS-0178] At cycle k, ATP shall consider that OdometerState changes from NOT_INITIALIZED to INVALID if sensors test is not consistent at cycle k.	cycle k ; ATP ; OdometerState ; NOT_INITIALIZED ; INVALID	<cycle> <system> <variable> <statevariable> <statevariable>	3 7 4 ; 3 2 2 ; 4 2 2 ; 0 6 3 ; 0 6 4 ; 1 1 2	if ((<variable_2> (k-1) = <statevariable_3>) and UnconsistentSensorTest(k))  <variable_2> = <statevariable_4>	2 3 4 6 7 8 5 -1
[iTC_CC_ATP-SwRS-0179]InitializationTimer, ATP shall accumulate the time for waiting cog position ready state.	ATP ; cog position ready state ; InitializationTimer	<system> <state> <variable>	0 1 1	if (OdometerState(k-1) == WAITING_COG_POSITION_CODE_READY and OdometerState(k) == WAITING_COG_POSITION_CODE_READY)  <variable_2> =  <variable_2> (k-1) + 1 elif (OdometerState(k-1) != WAITING_COG_POSITION_CODE_READY and OdometerState(k) == WAITING_COG_POSITION_CODE_READY)  <variable_2> = 1 else:  <variable_2> = 0	2 3 -1
[iTC_CC_ATP-SwRS-0180] At cycle k, ATP shall consider that OdometerState changes from WAITING_COG_POSITION_CODE_READY to NOT_INITIALIZED if: wheel is detected stopped (WheelFilteredStopped), and cog position remains unknown (not OdometerCogPositionReady), and there is no sensors test inconsistency, and time elapsed since last time OdometerState was NOT_INITIALIZED (InitializationTimer) is strictly less than ATPsetting.OdoInitTimeout.	cycle k ; ATP ; OdometerState ; WAITING_COG_POSITION_CODE_READY ; NOT_INITIALIZED ; WheelFilteredStopped ; not OdometerCogPositionReady ; InitializationTimer ; ATPsetting.OdoInitTimeout	<cycle> <system> <variable> <statevariable> <statevariable> <variable> <variable> <variable> <variable>	3 7 4 ; 3 2 2 ; 4 2 2 ; 1 1 2 ; 0 1 2 ; 5 1 2 ; 6 1 2 ; 5 7 6 ;  4 2 2 ; 2 10 8 ; 7 7 5 ; 7 7 6	if (<variable_2> (k-1) = <statevariable_3> ) and <variable_5> (k) and <variable_6> (k) and not UnconsistentSensorTest(k) and (<variable_7> (k) < <variable_8> )  <variable_2> =  <statevariable_4>	2 3 5 6 7 8 4 10 11 12 15 16 17 18 19 20 21 9 -1 
[iTC_CC_ATP-SwRS-0181] At cycle k, ATP shall consider that OdometerState changes from WAITING_COG_POSITION_CODE_READY to INITIALIZED If: Cog position is safely known which means that wheel angular position is well-known; and there is no sensors test inconsistency; and time elapsed since last time OdometerState was NOT_INITIALIZED (InitializationTimer) is strictly less than ATPsetting.OdoInitTimeout.	cycle k ; ATP ; OdometerState ; WAITING_COG_POSITION_CODE_READY ; INITIALIZED ; NOT_INITIALIZED ; InitializationTimer ; ATPsetting.OdoInitTimeout	<cycle> <system> <variable> <statevariable> <statevariable> <statevariable> <variable> <variable>	3 7 4 ; 3 2 2 ; 4 2 2 ; 1 1 2 ; 0 1 2 ; 5 2 2 ; 2 10 7 ; 7 1 2	if (<variable_2> (k-1) == <statevariable_3> and OdometerCogPositionReady(k) and not UnconsistentSensorTest(k) and (<variable_6> (k)< <variable_7> ))   <variable_2> = <statevariable_4>	2 3 6 7 4 9 10 11 15 16 8 -1
[iTC_CC_ATP-SwRS-0182] At cycle k, ATP shall consider that OdometerState changes from WAITING_COG_POSITION_CODE_READY to INVALID if: sensors test inconsistency is detected, or time elapsed since last time OdometerState was NOT_INITIALIZED (InitializationTimer) is more than or equal to the ATPsetting.OdoInitTimeout	 cycle k ; ATP ; OdometerState ; WAITING_COG_POSITION_CODE_READY ; INVALID ; InitializationTimer ; ATPsetting.OdoInitTimeout ; NOT_INITIALIZED	<cycle> <system> <variable> <statevariable> <statevariable> <variable> <variable> <statevariable>	3 2 2 ; 4 2 2 ; 3 7 4 ; 0 6 2 ; 1 1 2 ; 7 2 2 ; 2 10 6 ; 5 10 6	if (<variable_2>  (k-1) ==  <statevariable_3> ) and ((<variable_5> (k)>= <variable_6>) or UnconsistentSensorTest(k))  <variable_2>= <statevariable_4>	2 3 5 6 4 9 10 11 15 16 8 -1
[iTC_CC_ATP-SwRS-0183] When OdometerStateis initializing, wheel movement shall be over and under estimated considering maximum acceleration per cycle according with the train front:	OdometerState ; initializing ;  wheel movement ; maximum acceleration ; train front:	<otheritem> ; <state> ; <otheritem> <otheritem> ; <hardware>	1 2 0 ; 2 9 3	 if (<variable_0> (k) ==  WAITING_COG_POSITION_CODE_READY) if ((TrainFrontEnd(k-1) == END_2) or (NoUndetectableDanger_2(k-1) == True))  WheelMinimumMovement(k) = WheelMinimumMovement(k-1) + ATPsetting.MaxMotionPerCycle  WheelMaximumMovement(k) = WheelMaximumMovement(k-1) - ATPsetting.MaxMotionPerCycle else:  WheelMinimumMovement(k) = WheelMinimumMovement(k-1) — ATPsetting.MaxMotionPerCycle  WheelMaximumMovement(k) = WheelMaximumMovement(k-1) + ATPsetting.MaxMotionPerCycle
[iTC_CC_ATP-SwRS-0186] At cycle k, ATP shall consider that OdometerState changes from INITIALIZED to INVALID if: OdometerState was evaluated Initialized at cycle k-1, And: Sensors test result is inconsistent; Or neither wheel filtered stopped nor cog position ready.	cycle k ; ATP ; OdometerState ; INITIALIZED ; INVALID ; cycle k-1 ; wheel filtered stopped ; cog position ready	<cycle> <system> <variable> <statevariable> <statevariable> <cycle>  <otheritem>  <otheritem>	3 2 2 ; 4 2 2 ; 3 7 4 ; 0 6 2 ; 1 1 2 ; 4 2 2 ; 2 10 5	if(<variable_0> (k-1) is <statevariable_0> and ((UnconsistentSensorTest(k) == True) or (not WheelFilteredStopped(k) and not OdometerCogPositionReady(k)))): <variable_0> = <statevariable_1>	0 0 1 9 10 11 14 8 -1
[iTC_CC_ATP-SwRS-0189] At cycle k, ATP shall consider that OdometerState changes from INVALID to NOT_INITIALIZED if: OdometerState was evaluated Invalid at cycle k-1, and wheel is detected stopped (WheelFilteredStopped), and there is no sensors test inconsistency(UnconsistentSensorTest).	cycle k ; ATP ; OdometerState ; INVALID ; NOT_INITIALIZED ; cycle k-1 ; WheelFilteredStopped ; UnconsistentSensorTest	<cycle> <system> <variable> <statevariable> <statevariable> <cycle> <variable> <variable>	3 2 2 ; 4 2 2 ; 3 4 7 ; 0 6 2 ; 1 1 2 ; 4 2 2 ; 2 10 5 ; 6 7 7	if(<variable_0> (k-1) == <statevariable_0> and <variable_1> (k) and not <variable_2> (k)) <variable_0> = <statevariable_1>	0 0 1 2 1 9 10 11 14 16 8 -1
[iTC_CC_ATP-SwRS-0578] In INVALID status, ATP shall calculate wheel movement by using measured value of the odometer.	INVALID ; ATP ; wheel movement ; measured value of the odometer	<state> <system> <variable> <variable>	0 6 1 ; 3 1 2	if(OdometerState(k) == <state_0>) WheelMinimumMovement(k) = MinCogCalibration(k-1) * (TeethCounter(k) - TeethCounter(k-1)) WheelMaximumMovement(k) = MaxCogCalibration(k-1) * (TeethCounter(k) - TeethCounter(k-1))	0 4 -1
[iTC_CC_ATP-SwRS-0170] SensorTestContradiction, NoCommunicationWithOdometer, ATP shall invalidate wheel kinematic if minimum odometer motion is null and sensors test is not performed for more than ATPsetting.OdoTestContradictionDuration.	ATP ; ATPsetting.OdoTestContradictionDuration ; SensorTestContradiction ; NoCommunicationWithOdometer	<system> <variable> <variable> <variable>	2 10 1 ; 2 1 3 ; 1 1 3	def <variable_1> (k): return (not WheelFilteredStopped(k) and TeethCounter(k-1) == TeethCounter(k-2) and not SensorTestPerformed(k)) def <variable_2> (k): if(Initialization or not <variable_1> (k)):  SensorTestContradictionDuration = 0 return False else:  SensorTestContradictionDuration = SensorTestContradictionDuration(k-1) + 1 if (SensorTestContradictionDuration > <variable_0>): return True else: return False	1 2 0 5 6 7 4 -1
[iTC_CC_ATP-SwRS-0190] ValidWheelKinematic, Wheel kinematic is valid if odometer is valid, the calculated motion is not greater than the default value, and there is communication with odometer.	 Wheel kinematic ; valid ; odometer ; the calculated motion ; the default value ; ValidWheelKinematic	<variable> <state> <variable> <variable> <variable> <variable>	2 1 0 ; 2 6 1 ; 3 10 4 ; 0 1 5	<variable_4> (k) = ((OdometerState(k) != INVALID) and (not WheelKinematicsInvalidForCogCount(k)) and (not NoCommunicationWithOdometer(k)))	4 6 -1
[iTC_CC_ATP-SwRS-0204] WheelMaxSpeed, ATP calculates the maximum wheel speed according to WheelMaximumMovement; this value is non-negative and rounded up.	ATP ; WheelMaximumMovement ; WheelMaxSpeed	<system> <variable> <variable>	1 1 2	def <variable_1> (k): return round.ceil(abs(<variable_0> (k)) / ATP_CYCLE_TIME)	1 0 4 3 -1
[iTC_CC_ATP-SwRS-0202] FilteredWheelAcceleration measurement is the average of InstantaneousWheelAcceleration over FILTERED_ACCELERATION_NB cycles for filtering the fluctuation causing by the sampling period.	FilteredWheelAcceleration ; InstantaneousWheelAcceleration ; FILTERED_ACCELERATION_NB	<variable> <variable> <constant>	1 1 0 ; 2 1 0	<variable_0> (k) = (<variable_1> (k) + <variable_1> (k-1) + ... + <variable_1> (k-<constant_0> + 1)) / <constant_0>	0 1 0 4 5 -1
[iTC_CC_ATP-SwRS-0205] StartBrakingMovementMax, ATP records the maximum movement when the state transferring from COASTING to BRAKING or SLIDING, or from BRAKING to SLIDING.	StartBrakingMovementMax ; ATP ; COASTING ; BRAKING ; SLIDING	<variable> <system> <statevariable> <statevariable> <statevariable>	2 7 3 ; 2 7 4 ; 3 7 4	def <variable_0> (k): if(Initialization or (MotionOverEstimationState(k) is <statevariable_0>)): return 0 elif ((MotionOverEstimationState(k-1) is <statevariable_0> and MotionOverEstimationState(k) is <statevariable_1>) or (MotionOverEstimationState(k-1) is <statevariable_0> and MotionOverEstimationState(k) is <statevariable_2>) or (MotionOverEstimationState(k-1) is <statevariable_1> and MotionOverEstimationState(k) is <statevariable_2>))): return MaximumTrainMotion(k-1) else: return StartBrakingMovementMax(k-1)	0 1 2 6 7 8 5 -1
[iTC_CC_ATP-SwRS-0209] The state transfers from “COASTING” to “BRAKING” when:	COASTING ; BRAKING	<statevariable> <statevariable>	0 7 1	if((MotionOverEstimationState(k-1) == <statevariable_0>) and (WheelFilteredStopped(k) != True) and (FilteredWheelAcceleration(k) < ATPsetting.BrakingStartAcc) and (FilteredWheelAcceleration(k) >= ATPsetting.SlidingStartAcc) and OdometerState(k) is INITIALIZED) MotionOverEstimationState = <statevariable_1>	0 1 3 2 -1
[iTC_CC_ATP-SwRS-0210] The MotionOverEstimationState transfers from “COASTING” to “SLIDING” when:	MotionOverEstimationState ; COASTING ; SLIDING	<variable> <statevariable> <statevariable>	1 2 0 ; 2 2 0 ; 1 7 2	if((<variable_0> (k-1) == <statevariable_0>) and (WheelFilteredStopped(k) != True) and (FilteredWheelAcceleration(k) < ATPsetting.SlidingStartAcc) and OdometerState(k) is INITIALIZED) <variable_0> = <statevariable_1>	0 0 1 4 5 6 3 -1
[iTC_CC_ATP-SwRS-0213] The MotionOverEstimationState transfers from “BRAKING” to “SLIDING” when:	MotionOverEstimationState ; BRAKING ; SLIDING	<variable> <statevariable> <statevariable>	1 2 0 ; 2 2 0 ; 1 7 2	if((<variable_0> (k-1) == <statevariable_0>) and (FilteredWheelAccleration(k) < ATPsetting.SlidingStartAcc) and (AverageWheelAccleration(k) < ATPsetting.BrakingStartAcc) and (OdometerState(k) is INITIALIZED) and (not MaxMotionOdometerSignChanged(k))) <variable_0> = <statevariable_1> 0 0 1 4 5 6 3 -1
[iTC_CC_ATP-SwRS-0451] At cycle k, if motion overestimation status(MotionOverEstimationState) is SLIDING, ATP shall consider that sliding effect is ended (SlidingEnded) if FilteredWheelAcceleration is strictly less than ATPsetting.SlippingStopAcc and strictly greater than ATPsetting.SlidingStopAcc for more than ATPsetting.SlidingGripRecoveryTime.	cycle k ; MotionOverEstimationState ; SLIDING ; ATP ; SlidingEnded ; FilteredWheelAcceleration ; ATPsetting.SlippingStopAcc ; ATPsetting.SlidingStopAcc ; ATPsetting.SlidingGripRecoveryTime	<cycle> <variable> <statevariable> <system> <variable> <variable> <variable> <variable> <variable>	1 10 2 ; 5 1 4 ; 6 1 4 ; 7 1 4 ; 8 1 4 ; 5 10 6 ; 5 10 7	if(<variable_0>(k-1) == <statevariable_0> and (<variable_2> (k) < <variable_3>) and (<variable_2> (k) > <variable_4>) and (<variable_0>(k-2) == <statevariable_0>) and (<variable_2> (k-1) < <variable_3>) and (<variable_2> (k-1) > <variable_4>) ... and (<variable_0> (k - <variable_5>) == <statevariable_0>) and (<variable_2>(k - <variable_5> + 1) < <variable_3>) and (<variable_2> (k-<variable_5> + 1)) > <variable_4>)) <variable_1> = True else: <variable_1> = False	0 0 2 4 3 5 1 10 11 12 13 14 15 16 9 -1
[iTC_CC_ATP-SwRS-0452] At cycle k, if motion overestimation status(MotionOverEstimationState) is SLIDING, ATP shall consider that sliding is excess (SlidingExcess) if FilteredWheelAcceleration is strictly less than ATPsetting.SlippingStopAcc and strictly greater than ATPsetting.SlidingStopAcc for more than ATPsetting.SlidingExcessTime.	cycle k ; MotionOverEstimationState ; SLIDING ; ATP ; SlidingExcess ; FilteredWheelAcceleration ; ATPsetting.SlippingStopAcc ; ATPsetting.SlidingStopAcc ; ATPsetting.SlidingExcessTime	<cycle> <variable> <statevariable> <system> <variable> <variable> <variable> <variable> <variable>	1 10 2 ; 5 1 4 ; 6 1 4 ; 7 1 4 ; 8 1 4 ; 5 10 6 ; 5 10 7 if(<variable_0>(k-1) == <statevariable_0> and (<variable_2> (k) < <variable_3>) and (<variable_2> (k) > <variable_4>) and (<variable_0>(k-2) == <statevariable_0>) and (<variable_2> (k-1) < <variable_3>) and (<variable_2> (k-1) > <variable_4>) ... and (<variable_0> (k - <variable_5>) == <statevariable_0>) and (<variable_2>(k - <variable_5> + 1) < <variable_3>) and (<variable_2> (k-<variable_5> + 1)) > <variable_4>)) <variable_1> = True else: <variable_1> = False	0 0 2 3 4 5 1 10 11 12 13 14 15 16 9 -1
[iTC_CC_ATP-SwRS-0735] StartBrakingMovementMin, ATP records the minimum movement when the state transferring from COASTING to BRAKING or SLIDING, or from BRAKING to SLIDING.	StartBrakingMovementMin ; ATP ; the minimum movement ; COASTING ; BRAKING ; SLIDING	<variable> <system> <variable> <statevariable> <statevariable> <statevariable>	1 8 2 ; 3 7 4 ; 3 7 5 ; 4 7 5	def <variable_0> (k): if(Initialization or OdometerState(k-1) is not INITIALIZED or (MotionOverEstimationState(k) is <statevariable_0>)): return 0 elif ((MotionOverEstimationState(k-1) is <statevariable_0> and MotionOverEstimationState(k) is <statevariable_1>) or (MotionOverEstimationState(k-1) is <statevariable_0> and MotionOverEstimationState(k) is <statevariable_2>) or (MotionOverEstimationState(k-1) is <statevariable_1> and MotionOverEstimationState(k) is <statevariable_2>)): return MinimumTrainMotion(k-1) else: return <variable_0> (k-1)	0 0 1 2 8 9 10 6 -1
[iTC_CC_ATP-SwRS-0788] OverestimatedMotionMax, In BRAKING state, the maximum train motion overestimated as ATPsetting.SlidingCoefficient (15% normally) at most. If the overestimated motion has greater than the start braking movement, ATP shall use the start breaking movement as the current train motion. That said the train speed during braking could not faster than before.  In state SLIDING:  If both WheelMaximumMovement and StartBrakingMovementMax are same direction, and the absolute value of the former is greater than the absolute value of the latter, indicating that due to the sampling error makes the measured movement greater than StartBrakingMovementMax. In this case, ATP shall uses WheelMaximumMovement as current train maximum motion. Otherwise, uses StartBrakingMovementMax as train maximum motion. In other state (COASTING, SKIDDING), uses measured wheel maximum movement as current overestimated maximum train motion.	OverestimatedMotionMax ; BRAKING ; ATPsetting.SlidingCoefficient ; ATP ; SLIDING ; WheelMaximumMovement ; StartBrakingMovementMax	<variable> <statevariable> <variable> <system> <statevariable> <variable> <variable>	2 1 0 ; 5 10 6 ; 5 2 0 ; 6 2 0	def <variable_0> (k): if MotionOverEstimationState is <statevariable_0>: if (sign(<variable_3> (k)) == sign(<variable_2>(k)) and abs(<variable_2> (k)) > abs(<variable_3> (k))): return <variable_2> (k) elif(<variable_3> (k) >= 0): return min(abs(<variable_3> (k)) , abs(<variable_2> (k) * <variable_1>)) else: return -1 * min(abs(<variable_3> (k)) , abs(<variable_3> (k)) , abs(<variable_2> (k) * <variable_1>)) elif MotionOverEstimationState (k) is <statevariable_1> if(sign(<variable_3> (k)) == sign(<variable_2> (k)) and abs(<variable_2> (k)) > abs(<variable_3> (k))): return <variable_2> (k) else: return <variable_3> (k) else: # Coasting and Skidding return <variable_2> (k)	0 0 3 2 1 1 8 9 10 11 7 -1
[iTC_CC_ATP-SwRS-0770] TimeInSlipping, ATP shall record how many cycles staying in SLIPPING state.	ATP ; SLIPPING ; cycles ; TimeInSlipping	<system> <statevariable> <cycle> <variable>	2 8 0	def <variable_0> (k): if( Initialization or (MotionUnderEstimationState(k-1) is <statevariable_0> and MotionUnderEstimationState(k) is not <statevariable_0>)): return 0 elif (MotionUnderEstimationState(k) is <statevariable_0>: return <variable_0> (k-1) + 1 else: return <variable_0> (k-1)	0 0 4 -1
[iTC_CC_ATP-SwRS-0771] The MotionUnderEstimationState transfers from “COASTING” to “MOTORING” when:	MotionUnderEstimationState ; COASTING ; MOTORING	<variable> <statevariable> <statevariable>	1 2 0 ; 2 2 0 ; 1 7 2	if(<variable_0> (k-1) is <statevariable_0> and OdometerAxleMotorized(k) and FilteredWheelAccleration(k) <= ATPsetting.SlippingStartAcc and FilteredWheelAccleration(k) > ATPsetting.TractionStartAcc and OdometerState(k) is INITIALIZED) <variable_0> = <statevariable_1>	0 0 1 4 5 6 3 -1
[iTC_CC_ATP-SwRS-0775] The MotionUnderEstimationState transfers from SLIPPING to COASTING when:	MotionUnderEstimationState ; SLIPPING ; COASTING	<variable> <statevariable> <statevariable>	1 2 0 ; 2 2 0 ; 1 7 2	if(<variable_0> (k-1) is <statevariable_0> and (OdometerState(k) is INVALID or not OdometerAxleMotorized(k))) <variable_0> = <statevariable_1>	0 0 1 4 5 6 3 -1
[iTC_CC_ATP-SwRS-0780] StartMotoringMovementMin, ATP records the minimum movement when the state transferring from COASTING to MOTORING or SLIPPING, or from MOTORING to SLIPPING.	StartMotoringMovementMin ; ATP ; COASTING ; MOTORING ; SLIPPING	<variable> <system> <statevariable> <statevariable> <statevariable>	0 8 1 ; 2 7 3 ; 2 7 4 ; 3 7 4	def <variable_0> (k): if(Initialization or OdometerState(k-1) is not INITIALIZED or (MotionUnderEstimationState(k) is <statevariable_0>)): return 0 elif((MotionUnderEstimationState(k-1) is <statevariable_0> and MotionUnderEstimationState(k) is <statevariable_1>) or (MotionUnderEstimationState(k-1) is <statevariable_0> and MotionUnderEstimationState(k) is <statevariable_2>) or (MotionUnderEstimationState(k-1) is <statevariable_1> and MotionUnderEstimationState(k) is <statevariable_2>)); return MinimumTrainMotion (k-1) else: return <variable_0> (k-1)	0 0 1 2 7 8 9 5 -1
[iTC_CC_ATP-SwRS-0228] SlipSlideModellingFault, When the overestimation or underesimation state is SKIDDING, or the motion signed changed in BRAKING or SLIDING state, ATP shall consider the overestimation model as fault.	SlipSlideModellingFault ; SKIDDING ; BRAKING ; SLIDING ; ATP	<variable> <statevariable> <statevariable> <statevariable> <system>	1 7 2 ; 1 7 3 ; 2 7 3	def <variable_0> (k): if(MotionOverEstimationState(k) is <statevariable_0> or MotionUnderEstimationState(k) is <statevariable_0> or ((MotionOverEstimationState(k-1) is <statevariable_1> or MotionOverEstimationState(k-1) is <statevariable_2>) and MaxMotionOdometerSignChanged(k)))): return True elif (MotionOverEstimationState(k-1) is COASTING and MotionUnderEstimationState(k-1) is COASTING) return False else: return <variable_0> (k-1)	0 0 1 2 6 7 8 5 -1
[iTC_CC_ATP-SwRS-0130] ReferenceSpeedUnderThreshold_2 defines whether the referenced speed 2 from CCNV is lower than a configurable threshold.	ReferenceSpeedUnderThreshold_2 ; CCNV ; the referenced speed 2 ; a configurable threshold	<variable> <system> <variable> <variable>	2 10 3 ; 2 1 0 ; 3 1 0	if(ATOcontrolTimeValid(k) == True) <variable_0> = NonVitalRequest.OdometerRef2SpeedUnderThreshold(k) else: <variable_0> = False	0 4 -1
[iTC_CC_ATP-SwRS-0231] OdometerRef 1.PossiblyDisabled, The independent source of odometry reference 1 said to disable if following conditions reached:  local source of odometry is available (ValidWheelKinematic), and OdometerSpeedUnderThreshold indicates that train speed is greater than reference speed threshold, and source of odometry reference 1 is available, and odometer reference 1 indicates that train speed is less than reference speed threshold.	OdometerRef 1.PossiblyDisabled ; ValidWheelKinematic ; OdometerSpeedUnderThreshold ; reference speed threshold ; train speed ; odometer reference 1	<variable> <variable> <variable> <variable> <variable> <variable>	4 1 2 ; 3 1 2 ; 4 10 3 ; 4 1 5 ; 3 1 5	<variable_0> (k) = (ReferenceSpeedAvailabled(k) and ReferenceSpeedUnderThreshold 1 (k) and OdometerSpeedAvailable (k) and not <variable_2> (k))	0 2 6 -1
[iTC_CC_ATP-SwRS-0235]  OdometerRef 1.OutOfOrder, The independent source of odometry reference 1 is said to be out of order if it is possibly disabled during more than ATPsetting.OdoLockedAxleDisablingLatency. When the independent source of odometry reference 1 had out of order, it considered not out of order one if the source of odometry reference 1 is possibly enabled during more than ATPsetting.OdoLockedAxleEnablingLatency:	OdometerRef 1.OutOfOrder ; ATPsetting.OdoLockedAxleDisablingLatency ; ATPsetting.OdoLockedAxleEnablingLatency ; odometry reference 1	<variable> <variable> <variable> <variable>	1 1 0 ; 2 1 0 ; 3 1 0	if(OdometerRef 1.PossiblyDisabled(k) == True and OdometerRef 1.PossiblyDisabled(k-1) == True ... and OdometerRef 1.PossiblyDisabled(k+1-<variable_1> == True) <variable_0> = True if(OdometerRef 1.PossiblyEnabled(k) == True and OdometerRef 1.PossiblyEnabled(k-1) == True ... and OdometerRef 1.PossiblyEnabled(k+1-<variable_2> == True) <variable_0> = False	0 1 2 3 5 6 4 -1
[iTC_CC_ATP-SwRS-0240] If AxlePossiblyLocked situation lasts more than ATPsetting.OdoLockedAxleTimeout, the odometer axle shall be considered locked. Once UnrecoverableAxleLocked set to True, it will stay at state True unless ATP re-initialized.	AxlePossiblyLocked ; ATPsetting.OdoLockedAxleTimeout ; UnrecoverableAxleLocked ; ATP	<variable> <variable> <variable> <system>	0 10 1 ; 1 1 2 ; 0 1 2	<variable_2> (k) = <variable_2> (k-1) or (<variable_0> (k) and <variable_0> (k-1) and ... and <variable_0> (k+1-<variable_1>)	0 1 2 5 6 7 4 -1
[iTC_CC_ATP-SwRS-0241] AxleLockedDetectionAvailable, If only one or no source of odometry is available, then ATP shall invalidate kinematic while this situation lasting.	AxleLockedDetectionAvailable ; odometry ; available ; ATP	<variable> <variable> <state> <system>	1 1 0 ; 1 6 2 ; 3 6 0	<variable_0> = ((not OdometerRef 1.OutOfOrder and ReferenceSpeedAvailable 1(k)) or (not OdometerRef 2.OutOfOrder and ReferenceSpeedAvailable 2(k)))	0 4 -1
[iTC_CC_ATP-SwRS-0242] WheelTrainKinematicCorrelation, Wheel and train kinematic shall consider correctly correlated if and only if: odometer axle is not detected locked(UnrecoverableAxleLocked), and odometer axle detection is available(AxleLockedDetectionAvailable)	WheelTrainKinematicCorrelation ; UnrecoverableAxleLocked ; AxleLockedDetectionAvailable	1 1 0 ; 2 1 0	<variable> <variable> <variable>	<variable_0> (k) = <variable_2> (k) and not <variable_1> (k)	0 1 2 4 5 3 -1
[iTC_CC_ATP-SwRS-0244] TrainStopped, train shall consider strictly stopped if and only if: wheel is detected strictly stopped, and train kinematic elaboration is valid, and wheel is not detected sliding.	TrainStopped ; wheel ; strictly stopped ; train kinematic elaboration ;  valid ; not detected sliding	<variable> <hardware> <state> <otheritem> <state> <state>	1 1 0 ; 3 1 0 ; 1 6 2 ; 3 6 4 ; 1 6 5	<variable_0> (k) = ((WheelStopped(k) == True) and ((MotionOverEstimationState == COASTING) or (MotionOverEstimationState == BRAKING)) and (ValidTrainKinematic(k) == True))	0 6 -1
[iTC_CC_ATP-SwRS-0245] TrainFilteredStopped, Train shall consider stopped with the tolerance of one cog detection if: wheel is detected at filtered stop, and train kinematic elaboration is valid, and wheel is not detected sliding.	TrainFilteredStopped ; wheel ; filtered stop ; train kinematic elaboration ; valid ; not detected sliding	<variable> <hardware> <state> <otheritem> <state> <state>	1 1 0 ; 3 1 0 ; 1 6 2 ; 3 6 4 ; 1 6 5	<variable_0> (k) = ((WheelFilteredStopped(k) == True) and ((MotionOverEstimationState == COASTING) or (MotionOverEstimationState == BRAKING)) and (ValidTrainKinematic(k) == True))	0 6 -1
[iTC_CC_ATP-SwRS-0463] If ATP is in the state of CALI_WAITING, can transform to the measuring state if following conditions fulfilled: a valid beacon has been received and this beacon belongs to a couple of calibration, and train kinematic was valid, and no excessive slip/slide effect was detected,  and WheelMinimumMovement is not null, Then, ATP shall memorize: position of the wheel before and after top location signal of received beacon, the ID of received beacon, the sign of the movement when crossing beacon,  and shall consider itself as CALI_MEASURING.	ATP ; CALI_WAITING ; WheelMinimumMovement ; CALI_MEASURING	<system> <statevariable> <variable> <statevariable>	1 7 3	if((CalibrationState(k-1) = <statevariable_0>) and (NewBeaconObtained(k) == True) and (TrackMap.BeaconBelongsToCalibrationCouple(BeaconMessage.Id(k)) == True) and (SlipSlideDetected(k) == False)) CalibrationMeasurementStartPositionMin = CogPositionBeforeTopLoc(k) CalibrationMeasurementStartPositionMax = CogPositionAfterTopLoc(k) CalibrationMeasurementStartBeacon = BeaconMessage.Id(k) CalibrationEnd1RunningForward = End1RunningForward(k) CalibrationState = <statevariable_1>	0 1 5 4 -1
[iTC_CC_ATP-SwRS-0195] CalibrationState, If ATP is in the state of CALI_MEASURING and following conditions fulfilled: train kinematic has been detected not valid, or excessive slip/slide effect has been detected, or WheelMinimumMovement sign is in the opposite direction of thus observed on first beacon or becomes null, or an unexpected beacon has been received. That is, a beacon not belonging calibration measurement couple. Then, ATP shall abort calibration process and back to CALI_WAITING.	ATP ; CALI_MEASURING ; WheelMinimumMovement ; CALI_WAITING ; CalibrationState ; train kinematic ; not valid	<system> <statevariable> <variable> <statevariable> <variable> <variable> <state>	1 0 4 ; 5 6 6 ; 3 0 4 ; 1 7 3	if((<variable_1> (k-1) = <statevariable_0>) and ((ValidTrainKinematic(k) == False) or (OdometerState(k) is INVALID) or (SlipSlideDetected(k) ==True) or (CalibrationEnd1RunningForward(k-1) != End1RunningForward(k)) or (TrainFilteredStopped(k) == True) or ((NewBeaconObtained(k) == True) and TrackMap.BeaconBelongsToCalibrationCouple(BeaconMessage.Id(k)) == False))) <variable_1> = <statevariable_1>	1 0 0 8 10 11 7 -1
[iTC_CC_ATP-SwRS-0648] TrainLocatedOnOtherATP, Only when ATP and redundant ATP are all in filtered stopped state, can ATP use redundant ATP location for initialization.	TrainLocatedOnOtherATP ; ATP ; redundant ATP ; filtered stopped ; initialization	<variable> <system> <system> <state> <state>	1 1 0 ; 2 1 0 ; 1 6 3 ; 2 6 3 ; 2 6 4	def <variable_0> (k): if(OtherATP(k).LocatedOnKnownPath and TrainFilteredStopped(k) and OtherATP(k).TrainFilteredStopped and Message.IsMoreRecent(OtherATP(k).LatestTimeOtherCore, TrainStoppedStartTime(k)) and not TrainLocatedOnKnownPath(k-1) and not TrainPresumablyLocalized(k)): <variable_0> = True else: <variable_0> = False return <variable_0>	0 5 -1
[iTC_CC_ATP-SwRS-0460] InverseLocation, ATP shall determine the correct order of the external and internal location of train END.	InverseLocation ; ATP ; correct ; order of the external and internal location ; train END	<variable> <system> <state> <otheritem> <hardware>	3 1 0 ; 3 6 2 ; 4 9 3	def <variable_0> (k): return (LocationBeforeReloc(k).Uncertainty < 0)	0 5 -1
[iTC_CC_ATP-SwRS-0253] LocationUncertaintyExceed, ATP shall calculate the uncertain distance between the external and internal locations of train END_2.	LocationUncertaintyExceed ; ATP ; distance between the external and internal locations; END_2	<variable> <system> <otheritem> <statevariable>	2 1 0 ; 3 9 2	def <variable_0> (k): return (LocationBeforeReloc(k).Uncertainty > ATPsetting.LocationMaxUncertaintyConfirmed)	0 4 -1
[iTC_CC_ATP-SwRS-0074] If either of ends can ensure the train integrity, ATP shall set TrainUnitIntegrity as True. If the project is not configured with the capture of train integrity, it is sure that the train can guarantees the integrity.	the train integrity ; ATP ; TrainUnitIntegrity ; True	<otheritem> <system> <variable> <state>	2 6 3 ; 0 1 2	def <variable_0> : return Offline.GetTrainUnitIntegrity(k)	0 4 -1
[iTC_CC_ATP-SwRS-0076] ATP shall consider the driver is in this cab if it captures that either end of cab activated, which shown by the data from DriverInCab_1 or  DriverInCab_2.	ATP ; cab ; DriverInCab_1 ; DriverInCab_2	<system> <hardware> <variable> <variable>	2 7 3 ; 1 1 2 ; 1 1 3	def <variable_0> (k): return Offline.GetDriverInCab_1(k) def <variable_1> (k): return Offline.GetDriverInCab_2(k)	0 1 5 4 -1
[iTC_CC_ATP-SwRS-0127] NonVitalSelectedFrontEnd represents the train front choice from CCNV.	NonVitalSelectedFrontEnd ; the train front choice ; CCNV	<variable> <otheritem> <system>	2 8 1	if (ATOcontrolTimeValid(k) == True) <variable_0> = NonVitalRequest.SelectedFrontEnd(k) else: <variable_0> = UNKNOW	0 3 -1
[iTC_CC_ATP-SwRS-0141] TractionAuthorisedSenseEnd1, If current EOA is valid and whose orientation is END_1, ATP shall authorize the train can move toward END_1.	TractionAuthorisedSenseEnd1 ; EOA ; valid ; END_1 ; ATP ; train	<variable> <variable> <state> <statevariable> <system> <hardware>	1 6 2 ; 1 1 0 ; 3 1 0	def <variable_0> (k): if (EndOfAuthorityValid(k) and TrainFrontEnd(k) is <statevariable_0>): <variable_0>= True else: <variable_0>= False return <variable_0>	0 0 9 6 -1
[iTC_CC_ATP-SwRS-0142] TractionAuthorisedSenseEnd2, If current EOA is valid and whose orientation is END_2, ATP shall authorize the train can move toward END_2.	TractionAuthorisedSenseEnd2 ; EOA ; valid ; END_2 ; ATP ; train	<variable> <variable> <state> <statevariable> <system> <hardware>	1 6 2 ; 1 1 0 ; 3 1 0	def <variable_0> (k): if (EndOfAuthorityValid(k) and TrainFrontEnd(k) is <statevariable_0>): <variable_0>= True else: <variable_0>= False return <variable_0>	0 0 9 6 -1
[iTC_CC_ATP-SwRS-0312] TrainEnergy, ATP shall calculate the train energy where EB indeed applied. The calculation shall consider the kinetic energy and the error of the potential energy. The ATPsetting.MPauthAltitudeMaxErrorEnergy means an algorithm error caused by offline tool to calculate the compensation gradients.	TrainEnergy ; ATP ; EB ; ATPsetting.MPauthAltitudeMaxErrorEnergy	<variable> <system> <state> <variable>	3 1 0 ; 0 6 2	<variable_0> = V2EbApplied * V2EbApplied + <variable_1>	0 1 5 4 -1
[iTC_CC_ATP-SwRS-0069] According to the status of TSRcontrollinhibition, ATP can judge whether it is necessary to handle TSR information.	TSRcontrollinhibition ; ATP ; TSR	<variable> <system> <variable>	0 1 2	def <variable_0> (k): return Offline.GetTSRcontrolInhibition(k)	0 3 -1
[iTC_CC_ATP-SwRS-0325] TrainPossiblyInOverEnergy, If the train energy exceeds the zone of point vital speed limitation, ATP shall consider the train possibly over energy.	 TrainPossiblyInOverEnergy ; train energy ; limitation ; over energy	<variable> <variable> <limitation> <state>	1 10 2 ; 3 1 0	def  <variable_0> (k): return (not ZoneVSLNotExceed(k) or not PointVSLNotExceed(k))	0 4 -1
[iTC_CC_ATP-SwRS-0326] TrainEnergyControlDisabled, If the RMF or RMR mode selected, ATP shall not monitor the train energy.	TrainEnergyControlDisabled ; RMF ; RMR ; ATP ; train energy	<variable> <variable> <variable> <system> <otheritem>	1 1 0 ; 2 1 0 ; 3 6 4	def <variable_0> (k): return MotionProtectionInhibition(k)	0 5 -1
[iTC_CC_ATP-SwRS-0294] If ATP cannot determine train is NotOnRestrictiveMoralTimeArea_1, and if this situation lasts more than ATPsetting. MTtimeout cycles, ATP shall consider that route exclusivity is not guaranteed and RouteExclusivityGuaranted_1 shall be set to False. If ATP detects that train is NotOnRestrictiveMoralTimeArea_1, route exclusivity shall consider as guaranteed for that direction of travel and RouteExclusivityGuaranted_1 shall set to True.	ATP ; NotOnRestrictiveMoralTimeArea_1 ; ATPsetting. MTtimeout ; RouteExclusivityGuaranted_1 ; False ; True	<system> <variable> <variable> <variable> <state> <state>	1 1 3 ; 2 1 3 ; 4 2 3 ; 5 2 3	def <variable_2> (k): if (Initialization): <variable_2> = <state_0> elif (<variable_2> (k-1) and not <variable_0> (k)): if(MoralTimeTimer_1(k-1) < round.floor(<variable_1>)): MoralTimeTimer_1 = MoralTimeTimer_1(k-1) + 1 else: <variable_2> = <state_0> elif (<variable_0> (k)): MoralTimeTimer_1 = 1 <variable_2> = <state_1> else: <variable_2> = <variable_2> (k-1) return <variable_2>	2 0 0 1 1 7 8 9 10 6 -1
[iTC_CC_ATP-SwRS-0295] If ATP cannot determine train is NotOnRestrictiveMoralTimeArea_2, and if this situation lasts more than ATPsetting.MTtimeout cycles, ATP shall consider that route exclusivity is not guaranteed and RouteExclusivityGuaranted_2 shall set to False. If ATP detects that train is NotOnRestrictiveMoralTimeArea_2, route exclusivity shall consider as guaranteed for that direction of travel and RouteExclusivityGuaranted_2 shall set to True.	ATP ; NotOnRestrictiveMoralTimeArea_2 ; ATPsetting.MTtimeout ; RouteExclusivityGuaranted_2 ;  False ; True	<system> <variable> <variable> <variable> <state> <state>	1 1 3 ; 2 1 3 ; 4 2 3 ; 5 2 3	def <variable_2> (k): if (Initialization): <variable_2> = <state_0> elif (<variable_2> (k-1) and not <variable_0> (k)): if(MoralTimeTimer_1(k-1) < round.floor(<variable_1>)): MoralTimeTimer_1 = MoralTimeTimer_1(k-1) + 1 else: <variable_2> = <state_0> elif (<variable_0> (k)): MoralTimeTimer_1 = 1 <variable_2> = <state_1> else: <variable_2> = <variable_2> (k-1) return <variable_2>	2 0 0 1 1 7 8 9 10 6 -1
[iTC_CC_ATP-SwRS-0296] HazardousMotionOnNonExclusiveRoute, If RouteExclusivityGuaranted_1 is False, ATP shall request emergency braking if and only if: TrainFrontEnd is not END_2, RM forward nor RM reverse are not selected, and block mode is not selected. If RouteExclusivityGuaranted_2 is False, ATP shall request emergency braking if and only if: TrainFrontEnd is not END_1, RM forward nor RM reverse driving mode are not selected, and block mode is not selected.	RouteExclusivityGuaranted_1 ; False ; ATP ; TrainFrontEnd ; END_2 ; RM ; block mode ; not selected ; RouteExclusivityGuaranted_2 ; END_1 ; HazardousMotionOnNonExclusiveRoute	<variable> <state> <system> <variable> <statevariable> <variable> <variable> <state> <variable> <statevariable> <variable>	0 6 1 ; 9 2 3 ; 5 6 7 ; 6 6 7 ; 8 6 1 ; 4 2 3	def <variable_5> (k): return ((not <variable_0> (k) and (<variable_1> (k) != <statevariable_0>)) or (not <variable_1> (k) and (<variable_1> (k) != <statevariable_1>))) and not MotionProtectionInhibition(k) and BlockModeUsed (k))	5 0 1 0 1 13 17 11 -1
[iTC_CC_ATP-SwRS-0582] NoUndetectableDanger_1, The No Undetectable Danger in Extremity 1 shall be consider as permissive status according to project configuration.	NoUndetectableDanger_1 ; permissive ; project configuration	<variable> <state> <otheritem>	0 6 1 ; 2 1 1	def <variable_0> (k): return Offline.<variable_0>(k)	0 3 -1
[iTC_CC_ATP-SwRS-0583] NoUndetectableDanger_2, The "No Undetectable Danger in Extremity 2" shall be consider as permissive status according to project configuration.	NoUndetectableDanger_2 ; permissive ; project configuration	<variable> <state> <otheritem>	0 6 1 ; 2 1 1	def <variable_0> (k): return Offline.<variable_0>(k)	0 3 -1
[iTC_CC_ATP-SwRS-0285] UndetectableDangerRiskForNoNUDE, If there is neither No Undetectable Danger in Extremity 1(NoUndetectableDanger_1) nor No Undetectable Danger in Extremity 2(NoUndetectableDanger_2) inputs, ATP shall consider the train is possible under the risk of undetectable danger.	UndetectableDangerRiskForNoNUDE ; NoUndetectableDanger_1 ; NoUndetectableDanger_2 ; ATP	<variable> <variable> <variable> <system>	1 1 0 ; 2 1 0 ; 1 7 2	def <variable_0> (k): return (not <variable_1>(k) and not <variable_2>(k))	0 1 2 5 6 7 4 -1
[iTC_CC_ATP-SwRS-0287] NUDEdistanceAccount_1, When the driver does not authorize the train running toward the END_1, ATP shall accumulate the distance of the train running toward to the END_1. If in initialization, or the NoUndetectableDanger_1 is True, or the train has triggered EB and has stopped, ATP set this distance to 0; Else if train kinematic has invalid, ATP set this distance to the default value. Else if the odometer has initialized: If the MaximumTrainMotion is greater than 0, ATP accumulate the maximum movement in this cycle with the distance of last cycle; Or if the MaximumTrainMotion is less than or equal to 0, ATP use the minimum movement of this cycle plus to the distance last cycle (in fact, decrease the accumulated distance). The minimum of this accumulated distance is 0. Otherwise, keep the distance unchanged.	NUDEdistanceAccount_1 ; END_1 ; ATP ; NoUndetectableDanger_1 ; True ; train ; EB ; stopped ; distance ; 0 ; train kinematic ; invalid ; odometer ; initialized ; MaximumTrainMotion   <variable> <statevariable> <system> <variable> <state> <hardware> <variable> <state> <variable> <constant> <variable> <statevariable> <variable> <statevariable> <variable>	3 6 4 ; 6 6 7 ; 9 2 8 ; 10 6 11 ; 12 6 13 ; 14 10 9 ; 3 1 0 ; 14 1 0	def <variable_0> (k): if (INITIALIZATION or <variable_1> (k) or (EBappliedForMotionWithoutNUDE(k-1) and TrainFilteredStopped(k))) return <constant_0> elif (ValidTrainKinematic(k) != <state_0> return ATPsetting.NUDEdistanceWithoutMotionAvailable elif (OdometerState(k) is INITIALIZATION) if (End1RunningForward(k)) return max(<constant_0>, <variable_0> (k-1) + <variable_6> (k)) else: return max(<constant_0>, <variable_0> (k-1) + MinimumTrainMotion(k)) else: return < variable_0> (k-1)	0 1 0 0 6 16 21 22 23 15 -1
[iTC_CC_ATP-SwRS-0290] The EB request shall be maintained to True during the application time ATPsetting.NUDEtrainStopDurationBeforeEBrelease, if the train has moved without NUDE more than project restricted distance. When UndetectDangerMotionWithoutNUDE is True, ATP shall set EBappliedForMotionWithoutNUDE to True; When UndetectDangerMotionWithoutNUDE change from True to False,  ATP shall maintain EBappliedForMotionWithoutNUDE to True in period ATPsetting.NUDEtrainStopDurationBeforeEBrelease; Over the time, set this value to False.	EB ; True ; ATPsetting.NUDEtrainStopDurationBeforeEBrelease ; NUDE ; restricted distance ; UndetectDangerMotionWithoutNUDE ; ATP ; EBappliedForMotionWithoutNUDE ; False	<variable> <state> <variable> <variable> <otheritem> <variable> <system> <variable> <state>	0 6 1 ; 5 6 1; 7 6 1 ; 5 6 8 ; 7 6 2 ; 7 6 8 ; 5 1 7 ; 2 1 7	def <variable_4> (k): if (<variable_3> (k)): NudeEBreleaseCounter = 0 return <state_0> elif (NudeEBreleaseCounter < <variable_1>): NudeEBreleaseCounter = NudeEBreleaseCounter(k-1) +1 return <state_0> else: return <state_1>	4 3 0 1 1 11 12 13 14 15 16 17 9 -1
[iTC_CC_ATP-SwRS-0497] NoDangerForRMoverSpeed, ATP estimates that current train maximum speed not exceeds the RM limit speed.	NoDangerForRMoverSpeed ; ATP ; maximum speed ; exceeds ; RM limit speed	<variable> <system> <variable> <state> <variable>	2 10 4 ; 2 1 0 ; 4 1 0	def <variable_0> (k): return (ValidTrainKinematic(k) and TrainMaxSpeed(k) <= RMlimitSpeedApplied(k))	0 5 -1
